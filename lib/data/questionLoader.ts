import { Question } from '@/lib/dynamodb';

// Static question data loader
export class StaticQuestionLoader {
  private static cache: Map<string, Question[]> = new Map();

  /**
   * Load questions for a specific programming language
   * @param language - The programming language (e.g., 'python', 'javascript')
   * @returns Promise<Question[]> - Array of questions
   */
  static async loadTechnicalQuestions(language: string): Promise<Question[]> {
    // Check cache first
    const cacheKey = `technical-${language}`;
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey)!;
    }

    try {
      // Dynamic import of the JSON file
      const questionModule = await import(`@/lib/data/questions/technical/${language}.json`);
      const questions: Question[] = questionModule.default;

      // Transform questions to ensure they have the correct structure
      const transformedQuestions = questions.map(q => ({
        ...q,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        global: true
      }));

      // Cache the results
      this.cache.set(cacheKey, transformedQuestions);
      
      return transformedQuestions;
    } catch (error) {
      console.error(`Failed to load questions for ${language}:`, error);
      return [];
    }
  }

  /**
   * Get all available programming languages
   * @returns string[] - Array of available language identifiers
   */
  static getAvailableLanguages(): string[] {
    // For now, return the languages we have data for
    // This could be dynamically generated by scanning the directory
    return [
      'general',
      'python',
      'javascript',
      'react',
      'nodejs',
      'java',
      'csharp',
    ];
  }

  /**
   * Clear the cache (useful for development or if questions are updated)
   */
  static clearCache(): void {
    this.cache.clear();
  }

  /**
   * Preload questions for multiple languages (optional optimization)
   * @param languages - Array of language identifiers to preload
   */
  static async preloadQuestions(languages: string[]): Promise<void> {
    const loadPromises = languages.map(lang => this.loadTechnicalQuestions(lang));
    await Promise.all(loadPromises);
  }
}

// Utility functions for question filtering and searching
export class QuestionUtils {
  /**
   * Filter questions by difficulty level
   */
  static filterByDifficulty(questions: Question[], difficulty: string): Question[] {
    if (difficulty === 'all') return questions;
    return questions.filter(q => (q as any).difficulty === difficulty);
  }

  /**
   * Filter questions by tags
   */
  static filterByTags(questions: Question[], tags: string[]): Question[] {
    if (tags.length === 0) return questions;
    return questions.filter(q => {
      const questionTags = (q as any).tags || [];
      return tags.some(tag => questionTags.includes(tag));
    });
  }

  /**
   * Search questions by text content
   */
  static searchQuestions(questions: Question[], searchTerm: string): Question[] {
    if (!searchTerm.trim()) return questions;
    
    const term = searchTerm.toLowerCase();
    return questions.filter(q => 
      q.question.toLowerCase().includes(term) ||
      q.answer.toLowerCase().includes(term) ||
      (q.context && q.context.toLowerCase().includes(term))
    );
  }

  /**
   * Get random subset of questions
   */
  static getRandomQuestions(questions: Question[], count: number): Question[] {
    const shuffled = [...questions].sort(() => 0.5 - Math.random());
    return shuffled.slice(0, count);
  }

  /**
   * Get questions grouped by difficulty
   */
  static groupByDifficulty(questions: Question[]): Record<string, Question[]> {
    const groups: Record<string, Question[]> = {
      beginner: [],
      intermediate: [],
      advanced: []
    };

    questions.forEach(q => {
      const difficulty = (q as any).difficulty || 'intermediate';
      if (groups[difficulty]) {
        groups[difficulty].push(q);
      }
    });

    return groups;
  }
}

// Type definitions for enhanced question structure
export interface TechnicalQuestion extends Question {
  difficulty: 'beginner' | 'intermediate' | 'advanced';
  tags: string[];
}

// Export default instance for convenience
export const questionLoader = StaticQuestionLoader;