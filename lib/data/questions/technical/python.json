[
  {
    "id": "python-1",
    "question": "What is the difference between a list and a tuple in Python?",
    "answer": "Lists and tuples are both sequence types in Python, but they have key differences:\n\n**Lists:**\n- Mutable (can be modified after creation)\n- Use square brackets []\n- Support item assignment, append, remove operations\n- Slightly slower due to mutability overhead\n\n**Tuples:**\n- Immutable (cannot be modified after creation)\n- Use parentheses ()\n- Cannot change elements after creation\n- Faster and more memory efficient\n- Can be used as dictionary keys (hashable)\n\n```python\n# List example\nmy_list = [1, 2, 3]\nmy_list[0] = 10\nmy_list.append(4)\nprint(my_list)  # [10, 2, 3, 4]\n\n# Tuple example\nmy_tuple = (1, 2, 3)\n# my_tuple[0] = 10  # TypeError\ncoordinates = {(0, 0): 'origin', (1, 1): 'point'}\n```",
    "context": "Basic Python data structures",
    "type": "TECHNICAL",
    "programming_language": "python",
    "difficulty": "beginner",
    "tags": ["data-structures", "lists", "tuples", "mutability"]
  },
  {
    "id": "python-2",
    "question": "Explain the difference between '==' and 'is' operators in Python.",
    "answer": "The == and is operators serve different purposes:\n\n**== (Equality operator):**\n- Compares the values of objects\n- Calls the __eq__ method\n- Returns True if values are equal\n\n**is (Identity operator):**\n- Compares the identity of objects (memory address)\n- Checks if both variables point to the same object\n- Uses id function internally\n\nThe difference is crucial: == checks if objects have the same value, while is checks if they are the same object in memory. Python caches small integers and some strings, so is might return True for small numbers but False for larger ones.\n\n```python\n# Values vs Identity\na = [1, 2, 3]\nb = [1, 2, 3]\nc = a\n\nprint(a == b)  # True (same values)\nprint(a is b)  # False (different objects)\nprint(a is c)  # True (same object)\n\n# Integer caching (-5 to 256)\nx = 5\ny = 5\nprint(x is y)  # True (cached)\n\nz = 1000\nw = 1000\nprint(z is w)  # False (not cached)\n\n# Always use 'is' with None\nvalue = None\nprint(value is None)  # Correct\n```",
    "context": "Python operators and object comparison",
    "type": "TECHNICAL",
    "programming_language": "python",
    "difficulty": "intermediate",
    "tags": ["operators", "comparison", "identity", "memory"]
  },
  {
    "id": "python-3",
    "question": "What are Python decorators and how do they work?",
    "answer": "Decorators are a powerful feature that allows you to modify or extend the behavior of functions or classes without permanently modifying their code. They use the @ syntax and are essentially functions that take another function as an argument.\n\n**How decorators work:**\n1. A decorator is a function that takes a function as input\n2. Returns a modified version of that function\n3. The @decorator_name syntax is syntactic sugar\n\n```python\n# Basic decorator\ndef my_decorator(func):\n    def wrapper(*args, **kwargs):\n        print(f\"Before {func.__name__}\")\n        result = func(*args, **kwargs)\n        print(f\"After {func.__name__}\")\n        return result\n    return wrapper\n\n@my_decorator\ndef greet(name):\n    print(f\"Hello, {name}!\")\n\ngreet(\"Alice\")\n# Output: Before greet, Hello Alice!, After greet\n\n# Decorator with parameters\ndef repeat(times):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            for _ in range(times):\n                result = func(*args, **kwargs)\n            return result\n        return wrapper\n    return decorator\n\n@repeat(3)\ndef say_hello():\n    print(\"Hello!\")\n\n# Built-in decorators\nclass MyClass:\n    @staticmethod\n    def static_method():\n        return \"Static method\"\n    \n    @property\n    def my_property(self):\n        return \"Property value\"\n```",
    "context": "Python advanced features and design patterns",
    "type": "TECHNICAL",
    "programming_language": "python",
    "difficulty": "intermediate",
    "tags": ["decorators", "functions", "design-patterns", "metaprogramming"]
  },
  {
    "id": "python-4",
    "question": "Explain Python's Global Interpreter Lock (GIL). What are its implications?",
    "answer": "The Global Interpreter Lock (GIL) is a mutex that protects access to Python objects, preventing multiple native threads from executing Python bytecodes simultaneously in a single process.\n\n**Key points about GIL:**\n- Only one thread can execute Python code at a time\n- Prevents race conditions with Python object reference counting\n- Makes single-threaded programs faster\n- Limits multi-threading effectiveness for CPU-bound tasks\n\n**Implications:**\n\n```python\nimport threading\nimport time\nfrom multiprocessing import Pool\nimport asyncio\n\n# CPU-bound task (limited by GIL)\ndef cpu_task():\n    return sum(i*i for i in range(1000000))\n\n# Threading won't help much for CPU-bound tasks\nstart = time.time()\nthreads = [threading.Thread(target=cpu_task) for _ in range(4)]\nfor t in threads: t.start()\nfor t in threads: t.join()\nprint(f\"Threading time: {time.time() - start:.2f}s\")\n\n# Solutions:\n# 1. Multiprocessing for CPU-bound\nwith Pool(4) as pool:\n    results = pool.map(cpu_task, range(4))\n\n# 2. asyncio for I/O-bound\nasync def io_task():\n    await asyncio.sleep(1)  # Simulates I/O\n\nasync def main():\n    await asyncio.gather(*[io_task() for _ in range(4)])\n```",
    "context": "Python internals and concurrency",
    "type": "TECHNICAL",
    "programming_language": "python",
    "difficulty": "advanced",
    "tags": [
      "GIL",
      "threading",
      "concurrency",
      "performance",
      "multiprocessing"
    ]
  },
  {
    "id": "python-5",
    "question": "What are Python generators and how do they differ from regular functions?",
    "answer": "Generators are special functions that return an iterator object and produce values on-demand using the yield keyword. They provide memory-efficient iteration over large datasets.\n\n**Key differences from regular functions:**\n- Use yield instead of return\n- Maintain state between calls\n- Return a generator object (iterator)\n- Lazy evaluation (values computed when needed)\n- Memory efficient for large datasets\n\n```python\n# Regular function vs Generator\ndef create_list(n):\n    return [i*i for i in range(n)]  # Creates all at once\n\ndef create_generator(n):\n    for i in range(n):\n        yield i*i  # Yields one at a time\n\n# Usage\nsquares_list = create_list(5)     # [0, 1, 4, 9, 16]\nsquares_gen = create_generator(5)  # <generator object>\nprint(list(squares_gen))          # [0, 1, 4, 9, 16]\n\n# State preservation\ndef countdown(n):\n    while n > 0:\n        yield n\n        n -= 1\n\ncounter = countdown(3)\nprint(next(counter))  # 3\nprint(next(counter))  # 2\nprint(next(counter))  # 1\n\n# Generator expressions\nsquares = (x*x for x in range(5))\n\n# Memory efficiency example\nimport sys\nlist_obj = [x for x in range(1000)]     # ~9KB\ngen_obj = (x for x in range(1000))      # ~128 bytes\n\n# yield from delegation\ndef sub_gen():\n    yield 1; yield 2\n\ndef main_gen():\n    yield 'start'\n    yield from sub_gen()\n    yield 'end'\n\nprint(list(main_gen()))  # ['start', 1, 2, 'end']\n```",
    "context": "Python iterators and memory management",
    "type": "TECHNICAL",
    "programming_language": "python",
    "difficulty": "intermediate",
    "tags": [
      "generators",
      "iterators",
      "yield",
      "memory-efficiency",
      "lazy-evaluation"
    ]
  },
  {
    "id": "python-6",
    "question": "Explain the difference between *args and **kwargs in Python.",
    "answer": "*args and **kwargs are used to handle variable-length arguments in Python functions, allowing functions to accept any number of positional and keyword arguments.\n\n***args (Variable Positional Arguments):**\n- Collects extra positional arguments into a tuple\n- The name 'args' is conventional, you can use any name\n- The * is what makes it special\n\n****kwargs (Variable Keyword Arguments):**\n- Collects extra keyword arguments into a dictionary\n- The name 'kwargs' is conventional\n- The ** is what makes it special\n\n```python\n# Basic usage\ndef sum_all(*args):\n    print(f\"args: {args}\")  # tuple\n    return sum(args)\n\nprint(sum_all(1, 2, 3, 4))  # args: (1, 2, 3, 4), result: 10\n\ndef print_info(**kwargs):\n    print(f\"kwargs: {kwargs}\")  # dict\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nprint_info(name=\"Alice\", age=30)\n\n# Combined usage\ndef flexible_func(required, *args, **kwargs):\n    print(f\"Required: {required}\")\n    print(f\"Args: {args}\")\n    print(f\"Kwargs: {kwargs}\")\n\nflexible_func(\"Hello\", 1, 2, name=\"Bob\", age=25)\n\n# Unpacking arguments\ndef greet(first, last, age):\n    return f\"Hello {first} {last}, age {age}\"\n\nnames = [\"John\", \"Doe\", 30]\nprint(greet(*names))  # Unpacking list\n\nperson = {\"first\": \"Jane\", \"last\": \"Smith\", \"age\": 25}\nprint(greet(**person))  # Unpacking dict\n\n# Order matters: positional, *args, keyword-only, **kwargs\ndef complex_func(pos, *args, keyword_only, default=\"def\", **kwargs):\n    print(f\"pos: {pos}, args: {args}\")\n    print(f\"keyword_only: {keyword_only}, default: {default}\")\n    print(f\"kwargs: {kwargs}\")\n\ncomplex_func(1, 2, 3, keyword_only=\"required\", extra=\"value\")\n```",
    "context": "Python function parameters and argument handling",
    "type": "TECHNICAL",
    "programming_language": "python",
    "difficulty": "intermediate",
    "tags": ["functions", "arguments", "args", "kwargs", "unpacking"]
  },
  {
    "id": "python-7",
    "question": "What are Python context managers and how do you implement them?",
    "answer": "Context managers are objects that define methods to be used with the with statement. They ensure proper setup and cleanup of resources, even if exceptions occur.\n\n**Context Manager Protocol:**\n- __enter__(): Called when entering the with block\n- __exit__(): Called when exiting the with block (even on exceptions)\n\n**Implementation methods:**\n1. Class-based (implementing __enter__ and __exit__)\n2. Function-based using @contextmanager decorator\n\n```python\n# Class-based context manager\nclass FileManager:\n    def __init__(self, filename, mode):\n        self.filename = filename\n        self.mode = mode\n    \n    def __enter__(self):\n        self.file = open(self.filename, self.mode)\n        return self.file\n    \n    def __exit__(self, exc_type, exc_value, traceback):\n        self.file.close()\n        return False  # Don't suppress exceptions\n\nwith FileManager('test.txt', 'w') as f:\n    f.write('Hello!')\n# File automatically closed\n\n# Function-based with decorator\nfrom contextlib import contextmanager\nimport time\n\n@contextmanager\ndef timer():\n    start = time.time()\n    try:\n        yield start\n    finally:\n        print(f\"Elapsed: {time.time() - start:.2f}s\")\n\nwith timer():\n    time.sleep(1)  # Some operation\n\n# Built-in context managers\nimport threading\nlock = threading.Lock()\n\nwith lock:\n    print(\"Critical section\")  # Lock auto-released\n\n# Multiple context managers\nwith open('input.txt', 'r') as infile, \\\n     open('output.txt', 'w') as outfile:\n    outfile.write(infile.read().upper())\n```",
    "context": "Python resource management and cleanup patterns",
    "type": "TECHNICAL",
    "programming_language": "python",
    "difficulty": "intermediate",
    "tags": [
      "context-managers",
      "with-statement",
      "resource-management",
      "cleanup",
      "decorators"
    ]
  },
  {
    "id": "python-8",
    "question": "Explain Python's memory management and garbage collection.",
    "answer": "Python uses automatic memory management with reference counting as the primary mechanism, supplemented by a cyclic garbage collector for handling circular references.\n\n**Key Components:**\n1. **Reference Counting**: Tracks how many references point to an object\n2. **Garbage Collector**: Handles circular references\n3. **Memory Pools**: Optimizes allocation for small objects\n4. **Object Interning**: Reuses immutable objects\n\n```python\nimport sys\nimport gc\n\n# Reference counting\nclass MyClass:\n    def __init__(self, name):\n        self.name = name\n    def __del__(self):\n        print(f\"{self.name} destroyed\")\n\nobj = MyClass(\"test\")\nprint(f\"Refs: {sys.getrefcount(obj)}\")  # Usually 2\nobj_ref = obj  # Increases count\ndel obj_ref    # Decreases count\ndel obj        # Object destroyed\n\n# Circular reference problem\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.parent = None\n        self.children = []\n    \n    def add_child(self, child):\n        child.parent = self  # Creates cycle\n        self.children.append(child)\n\nroot = Node(\"root\")\nchild = Node(\"child\")\nroot.add_child(child)\ndel root, child  # Objects not destroyed immediately\n\n# Force garbage collection\ncollected = gc.collect()\nprint(f\"Collected {collected} objects\")\n\n# Memory optimization tips\n# 1. Use __slots__ to reduce memory\nclass EfficientClass:\n    __slots__ = ['x', 'y']\n    def __init__(self, x, y):\n        self.x, self.y = x, y\n\n# 2. Use generators for large datasets\ndef large_data():\n    for i in range(1000000):\n        yield i*i  # Memory efficient\n\n# 3. Weak references to avoid cycles\nimport weakref\n# child.parent = weakref.ref(root)  # Doesn't create strong ref\n```",
    "context": "Python internals and performance optimization",
    "type": "TECHNICAL",
    "programming_language": "python",
    "difficulty": "advanced",
    "tags": [
      "memory-management",
      "garbage-collection",
      "reference-counting",
      "performance",
      "optimization"
    ]
  },
  {
    "id": "python-9",
    "question": "What is the difference between deep copy and shallow copy in Python?",
    "answer": "Shallow copy and deep copy are two ways to copy objects in Python, differing in how they handle nested objects.\n\n**Shallow Copy:**\n- Creates a new object but inserts references to objects found in the original\n- Only copies the top-level object\n- Nested objects are shared between original and copy\n\n**Deep Copy:**\n- Creates a new object and recursively copies all nested objects\n- Creates completely independent copy\n- Changes to nested objects don't affect the original\n\n```python\nimport copy\n\n# Example with nested lists\noriginal = [[1, 2], [3, 4]]\n\n# Shallow copy methods\nshallow = original.copy()     # or original[:] or list(original)\ndeep = copy.deepcopy(original)\n\nprint(\"Before modification:\")\nprint(f\"Original: {original}\")\nprint(f\"Shallow: {shallow}\")\nprint(f\"Deep: {deep}\")\n\n# Check object identity\nprint(f\"Nested objects same (shallow): {original[0] is shallow[0]}\")  # True\nprint(f\"Nested objects same (deep): {original[0] is deep[0]}\")        # False\n\n# Modify nested object\noriginal[0][0] = 'CHANGED'\n\nprint(\"\\nAfter modifying original[0][0]:\")\nprint(f\"Original: {original}\")  # [['CHANGED', 2], [3, 4]]\nprint(f\"Shallow: {shallow}\")   # [['CHANGED', 2], [3, 4]] - affected!\nprint(f\"Deep: {deep}\")         # [[1, 2], [3, 4]] - not affected\n\n# With custom objects\nclass Person:\n    def __init__(self, name, hobbies):\n        self.name = name\n        self.hobbies = hobbies  # mutable list\n    \n    def __repr__(self):\n        return f\"Person('{self.name}', {self.hobbies})\"\n\noriginal_person = Person(\"Alice\", [\"reading\", \"swimming\"])\nshallow_person = copy.copy(original_person)\ndeep_person = copy.deepcopy(original_person)\n\n# Modify hobbies\noriginal_person.hobbies.append(\"cycling\")\noriginal_person.name = \"Alice Smith\"  # This won't affect copies\n\nprint(f\"\\nOriginal: {original_person}\")\nprint(f\"Shallow: {shallow_person}\")   # Hobbies affected\nprint(f\"Deep: {deep_person}\")         # Not affected\n```",
    "context": "Python object copying and memory management",
    "type": "TECHNICAL",
    "programming_language": "python",
    "difficulty": "intermediate",
    "tags": [
      "copy",
      "shallow-copy",
      "deep-copy",
      "objects",
      "memory",
      "mutability"
    ]
  },
  {
    "id": "python-10",
    "question": "Explain Python's duck typing and how it relates to polymorphism.",
    "answer": "Duck typing is a concept in Python where the type or class of an object is less important than the methods it defines. The name comes from the phrase: \"If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.\"\n\n**Key Principles:**\n- Objects are considered compatible if they implement the required methods\n- No need for explicit inheritance or interface declarations\n- Runtime checking of method availability\n- Promotes flexibility and code reusability\n\n```python\n# Duck typing example\nclass Duck:\n    def fly(self): return \"Duck flying\"\n    def quack(self): return \"Quack!\"\n\nclass Airplane:\n    def fly(self): return \"Airplane flying\"\n    def quack(self): return \"Plane can't quack\"\n\nclass Penguin:\n    def quack(self): return \"Penguin noise\"\n    # No fly method\n\ndef make_it_fly_and_quack(thing):\n    try:\n        print(thing.fly())\n        print(thing.quack())\n    except AttributeError as e:\n        print(f\"Error: {e}\")\n\n# All work despite different types\nmake_it_fly_and_quack(Duck())     # Works\nmake_it_fly_and_quack(Airplane()) # Works\nmake_it_fly_and_quack(Penguin())  # Error on fly()\n\n# File-like objects\nclass StringFile:\n    def __init__(self, content):\n        self.content = content\n        self.pos = 0\n    \n    def read(self):\n        result = self.content[self.pos:]\n        self.pos = len(self.content)\n        return result\n\ndef process_file(file_obj):\n    return f\"Read: {file_obj.read()}\"\n\n# Works with any file-like object\nfrom io import StringIO\nprint(process_file(StringIO(\"Hello StringIO\")))\nprint(process_file(StringFile(\"Hello StringFile\")))\n\n# Polymorphism with duck typing\nclass Rectangle:\n    def __init__(self, w, h): self.w, self.h = w, h\n    def area(self): return self.w * self.h\n\nclass Circle:\n    def __init__(self, r): self.r = r\n    def area(self): return 3.14 * self.r ** 2\n\ndef print_area(shape):\n    print(f\"Area: {shape.area()}\")\n\nshapes = [Rectangle(5, 3), Circle(4)]\nfor shape in shapes:\n    print_area(shape)  # Works with any shape\n\n# EAFP vs LBYL\ndef eafp_approach(obj):\n    try:\n        return obj.some_method()\n    except AttributeError:\n        return \"No method\"\n\ndef lbyl_approach(obj):\n    if hasattr(obj, 'some_method'):\n        return obj.some_method()\n    return \"No method\"\n\n# EAFP is more Pythonic\n```",
    "context": "Python type system and design patterns",
    "type": "TECHNICAL",
    "programming_language": "python",
    "difficulty": "intermediate",
    "tags": [
      "duck-typing",
      "polymorphism",
      "protocols",
      "type-system",
      "design-patterns"
    ]
  },
  {
    "id": "python-11",
    "question": "What are Python lambda functions and when would you use them?",
    "answer": "Lambda functions are small, anonymous functions that can have any number of arguments but can only have one expression. They are also known as anonymous functions because they don't have a name like regular functions defined with def.\n\n**Key characteristics:**\n- Single expression only (no statements)\n- Return value automatically (no return keyword needed)\n- Can be assigned to variables or used inline\n- Commonly used with map(), filter(), sort(), and other higher-order functions\n\n**When to use lambda functions:**\n- Short, simple operations that don't warrant a full function definition\n- As arguments to higher-order functions\n- When you need a function temporarily\n- Functional programming patterns\n\n```python\n# Basic lambda syntax\nsquare = lambda x: x ** 2\nprint(square(5))  # 25\n\n# Multiple arguments\naddition = lambda x, y: x + y\nprint(addition(3, 4))  # 7\n\n# With map()\nnumbers = [1, 2, 3, 4, 5]\nsquared = list(map(lambda x: x ** 2, numbers))\nprint(squared)  # [1, 4, 9, 16, 25]\n\n# With filter()\neven_numbers = list(filter(lambda x: x % 2 == 0, numbers))\nprint(even_numbers)  # [2, 4]\n\n# With sorted()\nstudents = [('Alice', 85), ('Bob', 90), ('Charlie', 78)]\nsorted_by_grade = sorted(students, key=lambda x: x[1])\nprint(sorted_by_grade)  # [('Charlie', 78), ('Alice', 85), ('Bob', 90)]\n\n# Alternative with regular function (for comparison)\ndef get_grade(student):\n    return student[1]\n\nsorted_students = sorted(students, key=get_grade)\n```",
    "context": "Python functional programming and built-in functions",
    "type": "TECHNICAL",
    "programming_language": "python",
    "difficulty": "beginner",
    "tags": [
      "lambda",
      "functional-programming",
      "anonymous-functions",
      "higher-order-functions"
    ]
  },
  {
    "id": "python-12",
    "question": "Explain Python's exception handling mechanism (try, except, finally, else).",
    "answer": "Python's exception handling allows you to gracefully handle errors and unexpected situations in your code without crashing the program.\n\n**Exception handling blocks:**\n- try: Code that might raise an exception\n- except: Code that runs when a specific exception occurs\n- else: Code that runs only if no exception occurred in try block\n- finally: Code that always runs, regardless of exceptions\n- raise: Manually raise an exception\n\n**Best practices:**\n- Catch specific exceptions rather than using bare except\n- Use finally for cleanup operations\n- Don't ignore exceptions silently\n- Use else block for code that should only run if no exceptions occurred\n\n```python\n# Basic exception handling\ntry:\n    result = 10 / 0\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero!\")\n    result = None\n\n# Multiple exception types\ntry:\n    number = int(input(\"Enter a number: \"))\n    result = 10 / number\nexcept ValueError:\n    print(\"Invalid input! Please enter a number.\")\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero!\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n\n# try-except-else-finally\ntry:\n    file = open(\"data.txt\", \"r\")\nexcept FileNotFoundError:\n    print(\"File not found!\")\nelse:\n    print(\"File opened successfully\")\n    content = file.read()\nfinally:\n    print(\"Cleanup operations\")\n    if 'file' in locals() and not file.closed:\n        file.close()\n\n# Custom exceptions\nclass InvalidAgeError(Exception):\n    def __init__(self, age):\n        self.age = age\n        super().__init__(f\"Invalid age: {age}. Age must be between 0 and 150.\")\n\ndef validate_age(age):\n    if age < 0 or age > 150:\n        raise InvalidAgeError(age)\n    return True\n\ntry:\n    validate_age(-5)\nexcept InvalidAgeError as e:\n    print(e)\n```",
    "context": "Python error handling and program robustness",
    "type": "TECHNICAL",
    "programming_language": "python",
    "difficulty": "intermediate",
    "tags": [
      "exceptions",
      "error-handling",
      "try-except",
      "finally",
      "custom-exceptions"
    ]
  },
  {
    "id": "python-13",
    "question": "What is the difference between __str__ and __repr__ methods in Python?",
    "answer": "Both __str__ and __repr__ are special methods (dunder methods) used to define string representations of objects, but they serve different purposes and audiences.\n\n**__str__ method:**\n- Intended for end users (human-readable)\n- Called by str() function and print()\n- Should return a nice, readable string\n- Informal string representation\n\n**__repr__ method:**\n- Intended for developers (unambiguous)\n- Called by repr() function and in interactive shell\n- Should return a string that could recreate the object\n- Official string representation\n- If __str__ is not defined, __repr__ is used as fallback\n\n**Best practice:** __repr__ should be unambiguous, __str__ should be readable.\n\n```python\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    \n    def __str__(self):\n        return f\"{self.name}, {self.age} years old\"\n    \n    def __repr__(self):\n        return f\"Person('{self.name}', {self.age})\"\n\nperson = Person(\"Alice\", 30)\n\n# Different outputs\nprint(str(person))   # Alice, 30 years old\nprint(repr(person))  # Person('Alice', 30)\nprint(person)        # Alice, 30 years old (uses __str__)\n\n# In interactive shell or debugger\nperson               # Person('Alice', 30) (uses __repr__)\n\n# List representation uses __repr__ for elements\npeople = [Person(\"Bob\", 25), Person(\"Carol\", 35)]\nprint(people)        # [Person('Bob', 25), Person('Carol', 35)]\n\n# Class with only __repr__\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __repr__(self):\n        return f\"Point({self.x}, {self.y})\"\n\npoint = Point(3, 4)\nprint(str(point))    # Point(3, 4) (falls back to __repr__)\nprint(repr(point))   # Point(3, 4)\n```",
    "context": "Python object representation and debugging",
    "type": "TECHNICAL",
    "programming_language": "python",
    "difficulty": "intermediate",
    "tags": [
      "dunder-methods",
      "string-representation",
      "debugging",
      "object-oriented"
    ]
  },
  {
    "id": "python-14",
    "question": "Explain Python's method resolution order (MRO) and multiple inheritance.",
    "answer": "Method Resolution Order (MRO) determines the order in which Python searches for methods in a class hierarchy, especially important in multiple inheritance scenarios.\n\n**Key concepts:**\n- Python uses C3 linearization algorithm for MRO\n- Ensures consistent method lookup order\n- Prevents issues like diamond problem\n- Can be viewed using ClassName.__mro__ or ClassName.mro()\n- super() function respects MRO\n\n**Multiple inheritance:**\n- A class can inherit from multiple parent classes\n- Method calls follow MRO to resolve conflicts\n- Left-to-right order in class definition affects MRO\n\n```python\n# Multiple inheritance example\nclass A:\n    def method(self):\n        print(\"Method from A\")\n\nclass B(A):\n    def method(self):\n        print(\"Method from B\")\n        super().method()\n\nclass C(A):\n    def method(self):\n        print(\"Method from C\")\n        super().method()\n\nclass D(B, C):\n    def method(self):\n        print(\"Method from D\")\n        super().method()\n\n# Check MRO\nprint(D.__mro__)\n# (<class 'D'>, <class 'B'>, <class 'C'>, <class 'A'>, <class 'object'>)\n\nd = D()\nd.method()\n# Output:\n# Method from D\n# Method from B\n# Method from C\n# Method from A\n\n# Diamond inheritance example\nclass Vehicle:\n    def start(self):\n        print(\"Vehicle starting\")\n\nclass Car(Vehicle):\n    def start(self):\n        print(\"Car starting\")\n        super().start()\n\nclass Electric(Vehicle):\n    def start(self):\n        print(\"Electric starting\")\n        super().start()\n\nclass ElectricCar(Car, Electric):\n    def start(self):\n        print(\"ElectricCar starting\")\n        super().start()\n\nprint(ElectricCar.mro())\nec = ElectricCar()\nec.start()\n# ElectricCar starting\n# Car starting\n# Electric starting\n# Vehicle starting\n```",
    "context": "Python object-oriented programming and inheritance",
    "type": "TECHNICAL",
    "programming_language": "python",
    "difficulty": "advanced",
    "tags": [
      "inheritance",
      "MRO",
      "multiple-inheritance",
      "super",
      "object-oriented"
    ]
  },
  {
    "id": "python-15",
    "question": "What are Python descriptors and how do they work?",
    "answer": "Descriptors are a powerful feature that allows you to customize attribute access (getting, setting, and deleting) on objects. They are the mechanism behind properties, methods, static methods, and class methods.\n\n**Descriptor protocol methods:**\n- __get__(self, obj, objtype=None): Called when accessing the attribute\n- __set__(self, obj, value): Called when setting the attribute\n- __delete__(self, obj): Called when deleting the attribute\n\n**Types of descriptors:**\n- Data descriptors: Define __get__ and (__set__ or __delete__)\n- Non-data descriptors: Only define __get__\n- Data descriptors have higher priority than instance dictionary\n\n```python\n# Basic descriptor example\nclass Validator:\n    def __init__(self, min_value=0, max_value=100):\n        self.min_value = min_value\n        self.max_value = max_value\n    \n    def __get__(self, obj, objtype=None):\n        if obj is None:\n            return self\n        return obj.__dict__.get(self.name, None)\n    \n    def __set__(self, obj, value):\n        if not self.min_value <= value <= self.max_value:\n            raise ValueError(f\"Value must be between {self.min_value} and {self.max_value}\")\n        obj.__dict__[self.name] = value\n    \n    def __set_name__(self, owner, name):\n        self.name = name\n\nclass Student:\n    grade = Validator(0, 100)\n    \n    def __init__(self, name, grade):\n        self.name = name\n        self.grade = grade\n\nstudent = Student(\"Alice\", 85)\nprint(student.grade)  # 85\n\ntry:\n    student.grade = 150  # ValueError\nexcept ValueError as e:\n    print(e)\n\n# Property decorator (built on descriptors)\nclass Temperature:\n    def __init__(self, celsius=0):\n        self._celsius = celsius\n    \n    @property\n    def celsius(self):\n        return self._celsius\n    \n    @celsius.setter\n    def celsius(self, value):\n        if value < -273.15:\n            raise ValueError(\"Temperature below absolute zero\")\n        self._celsius = value\n    \n    @property\n    def fahrenheit(self):\n        return (self._celsius * 9/5) + 32\n\ntemp = Temperature(25)\nprint(temp.fahrenheit)  # 77.0\ntemp.celsius = 30\nprint(temp.fahrenheit)  # 86.0\n```",
    "context": "Python advanced object-oriented programming",
    "type": "TECHNICAL",
    "programming_language": "python",
    "difficulty": "advanced",
    "tags": ["descriptors", "properties", "attribute-access", "advanced-oop"]
  },
  {
    "id": "python-16",
    "question": "Explain the difference between classmethod, staticmethod, and instance methods.",
    "answer": "Python provides three types of methods in classes, each with different purposes and access patterns.\n\n**Instance methods:**\n- Most common type of method\n- First parameter is always self (the instance)\n- Can access and modify instance and class attributes\n- Called on instances of the class\n\n**Class methods (@classmethod):**\n- First parameter is cls (the class itself)\n- Can access class attributes but not instance attributes\n- Often used for alternative constructors\n- Called on class or instances\n\n**Static methods (@staticmethod):**\n- No special first parameter\n- Cannot access instance or class attributes directly\n- Behaves like a regular function but belongs to the class namespace\n- Used for utility functions related to the class\n\n```python\nclass Person:\n    species = \"Homo sapiens\"  # Class attribute\n    \n    def __init__(self, name, age):\n        self.name = name  # Instance attribute\n        self.age = age\n    \n    # Instance method\n    def introduce(self):\n        return f\"Hi, I'm {self.name} and I'm {self.age} years old\"\n    \n    # Class method - alternative constructor\n    @classmethod\n    def from_birth_year(cls, name, birth_year):\n        age = 2024 - birth_year\n        return cls(name, age)  # Creates new instance\n    \n    @classmethod\n    def get_species(cls):\n        return cls.species\n    \n    # Static method - utility function\n    @staticmethod\n    def is_adult(age):\n        return age >= 18\n    \n    @staticmethod\n    def validate_age(age):\n        return 0 <= age <= 150\n\n# Instance method usage\nperson1 = Person(\"Alice\", 30)\nprint(person1.introduce())  # Hi, I'm Alice and I'm 30 years old\n\n# Class method usage - alternative constructor\nperson2 = Person.from_birth_year(\"Bob\", 1990)\nprint(person2.introduce())  # Hi, I'm Bob and I'm 34 years old\n\n# Class method - accessing class attributes\nprint(Person.get_species())  # Homo sapiens\n\n# Static method usage\nprint(Person.is_adult(25))     # True\nprint(Person.is_adult(15))     # False\nprint(Person.validate_age(30)) # True\n\n# Static methods can also be called on instances\nprint(person1.is_adult(20))    # True\n\n# Comparison of access capabilities\nclass Example:\n    class_var = \"I'm a class variable\"\n    \n    def __init__(self):\n        self.instance_var = \"I'm an instance variable\"\n    \n    def instance_method(self):\n        return f\"Instance: {self.instance_var}, Class: {self.class_var}\"\n    \n    @classmethod\n    def class_method(cls):\n        return f\"Class: {cls.class_var}\"\n        # Cannot access self.instance_var here\n    \n    @staticmethod\n    def static_method():\n        return \"I'm a static method with no special access\"\n        # Cannot access class_var or instance_var directly\n```",
    "context": "Python object-oriented programming and method types",
    "type": "TECHNICAL",
    "programming_language": "python",
    "difficulty": "intermediate",
    "tags": [
      "methods",
      "classmethod",
      "staticmethod",
      "instance-methods",
      "decorators"
    ]
  },
  {
    "id": "python-17",
    "question": "What are Python metaclasses and when would you use them?",
    "answer": "Metaclasses are classes whose instances are classes themselves. They define how classes are created and can be thought of as the class of a class. In Python, classes are objects too, and metaclasses are what create these class objects.\n\n**Key concepts:**\n- A metaclass is a class that creates classes\n- type is the default metaclass in Python\n- Metaclasses control class creation process\n- They intercept class creation and can modify class behavior\n- Follow the principle: Use metaclasses only when you really need them\n\n**When to use metaclasses:**\n- API frameworks (like Django ORM)\n- Design patterns requiring class modification\n- Automatic registration of classes\n- Validation of class definitions\n- Adding methods or attributes to classes automatically\n\n```python\n# Understanding type as metaclass\nclass MyClass:\n    pass\n\nprint(type(MyClass))        # <class 'type'>\nprint(type(type(MyClass)))  # <class 'type'>\n\n# Creating class with type() function\nDynamicClass = type('DynamicClass', (), {'attr': 'value'})\nprint(DynamicClass.attr)    # value\n\n# Custom metaclass example\nclass SingletonMeta(type):\n    _instances = {}\n    \n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super().__call__(*args, **kwargs)\n        return cls._instances[cls]\n\nclass Singleton(metaclass=SingletonMeta):\n    def __init__(self, value):\n        self.value = value\n\n# Testing singleton behavior\nobj1 = Singleton(\"first\")\nobj2 = Singleton(\"second\")\nprint(obj1 is obj2)     # True\nprint(obj1.value)       # first (not changed)\n\n# Metaclass for automatic method registration\nclass RegisteredMeta(type):\n    registry = {}\n    \n    def __new__(mcs, name, bases, attrs):\n        cls = super().__new__(mcs, name, bases, attrs)\n        if name != 'RegisteredBase':  # Skip base class\n            mcs.registry[name] = cls\n        return cls\n\nclass RegisteredBase(metaclass=RegisteredMeta):\n    pass\n\nclass PluginA(RegisteredBase):\n    def execute(self):\n        return \"Plugin A executed\"\n\nclass PluginB(RegisteredBase):\n    def execute(self):\n        return \"Plugin B executed\"\n\nprint(RegisteredMeta.registry)\n# {'PluginA': <class 'PluginA'>, 'PluginB': <class 'PluginB'>}\n\n# Using registered plugins\nfor name, plugin_class in RegisteredMeta.registry.items():\n    plugin = plugin_class()\n    print(f\"{name}: {plugin.execute()}\")\n\n# Validation metaclass\nclass ValidatedMeta(type):\n    def __new__(mcs, name, bases, attrs):\n        # Validate that required methods exist\n        required_methods = ['validate', 'process']\n        for method in required_methods:\n            if method not in attrs:\n                raise TypeError(f\"Class {name} must implement {method} method\")\n        return super().__new__(mcs, name, bases, attrs)\n\nclass DataProcessor(metaclass=ValidatedMeta):\n    def validate(self, data):\n        return True\n    \n    def process(self, data):\n        return data.upper()\n\n# This would raise TypeError:\n# class InvalidProcessor(metaclass=ValidatedMeta):\n#     pass\n```",
    "context": "Python advanced metaprogramming and class creation",
    "type": "TECHNICAL",
    "programming_language": "python",
    "difficulty": "advanced",
    "tags": [
      "metaclasses",
      "metaprogramming",
      "class-creation",
      "design-patterns",
      "advanced"
    ]
  },
  {
    "id": "python-18",
    "question": "Explain Python's asyncio and asynchronous programming concepts.",
    "answer": "Asyncio is Python's library for writing concurrent code using the async/await syntax. It's particularly useful for I/O-bound and high-level structured network code.\n\n**Key concepts:**\n- Asynchronous programming allows code to run concurrently\n- Event loop manages and executes asynchronous tasks\n- Coroutines are functions defined with async def\n- await keyword pauses execution until awaited operation completes\n- Non-blocking I/O operations improve performance\n\n**When to use async/await:**\n- I/O-bound operations (file reading, network requests)\n- Multiple concurrent operations\n- Web scraping, API calls\n- Real-time applications\n\n**Not suitable for:**\n- CPU-bound tasks (use multiprocessing instead)\n- Simple sequential operations\n\n```python\nimport asyncio\nimport aiohttp\nimport time\n\n# Basic async function\nasync def greet(name, delay):\n    print(f\"Hello {name}!\")\n    await asyncio.sleep(delay)  # Non-blocking sleep\n    print(f\"Goodbye {name}!\")\n\n# Running async function\nasync def main():\n    await greet(\"Alice\", 1)\n\n# Multiple concurrent tasks\nasync def concurrent_greetings():\n    tasks = [\n        greet(\"Alice\", 2),\n        greet(\"Bob\", 1),\n        greet(\"Charlie\", 3)\n    ]\n    await asyncio.gather(*tasks)  # Run concurrently\n\n# Async with context manager\nasync def fetch_url(session, url):\n    async with session.get(url) as response:\n        return await response.text()\n\nasync def fetch_multiple_urls():\n    urls = [\n        \"https://httpbin.org/delay/1\",\n        \"https://httpbin.org/delay/2\",\n        \"https://httpbin.org/delay/1\"\n    ]\n    \n    async with aiohttp.ClientSession() as session:\n        tasks = [fetch_url(session, url) for url in urls]\n        results = await asyncio.gather(*tasks)\n    return results\n\n# Async generator\nasync def async_range(start, stop):\n    for i in range(start, stop):\n        await asyncio.sleep(0.1)\n        yield i\n\nasync def consume_async_generator():\n    async for number in async_range(1, 5):\n        print(f\"Generated: {number}\")\n\n# Performance comparison\ndef sync_sleep(duration):\n    time.sleep(duration)\n    return f\"Slept for {duration} seconds\"\n\nasync def async_sleep(duration):\n    await asyncio.sleep(duration)\n    return f\"Async slept for {duration} seconds\"\n\nasync def compare_performance():\n    # Synchronous version\n    start = time.time()\n    results_sync = [sync_sleep(1) for _ in range(3)]\n    sync_time = time.time() - start\n    print(f\"Sync time: {sync_time:.2f} seconds\")\n    \n    # Asynchronous version\n    start = time.time()\n    tasks = [async_sleep(1) for _ in range(3)]\n    results_async = await asyncio.gather(*tasks)\n    async_time = time.time() - start\n    print(f\"Async time: {async_time:.2f} seconds\")\n\n# Running the examples\nif __name__ == \"__main__\":\n    # asyncio.run(main())\n    # asyncio.run(concurrent_greetings())\n    # asyncio.run(consume_async_generator())\n    asyncio.run(compare_performance())\n```",
    "context": "Python asynchronous programming and concurrency",
    "type": "TECHNICAL",
    "programming_language": "python",
    "difficulty": "advanced",
    "tags": [
      "asyncio",
      "async-await",
      "concurrency",
      "coroutines",
      "event-loop"
    ]
  },
  {
    "id": "python-19",
    "question": "What are Python comprehensions and what types are available?",
    "answer": "Comprehensions provide a concise way to create collections (lists, dictionaries, sets) and generators in Python. They offer a more readable and efficient alternative to traditional loops for creating collections.\n\n**Types of comprehensions:**\n- List comprehensions: Create lists\n- Dictionary comprehensions: Create dictionaries\n- Set comprehensions: Create sets\n- Generator expressions: Create generators (not technically comprehensions)\n\n**Benefits:**\n- More readable and concise than equivalent loops\n- Often faster than traditional loops\n- Functional programming style\n- Can include filtering and transformation in one expression\n\n**Syntax pattern:** [expression for item in iterable if condition]\n\n```python\n# List comprehensions\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# Basic list comprehension\nsquares = [x**2 for x in numbers]\nprint(squares)  # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n# With condition (filtering)\neven_squares = [x**2 for x in numbers if x % 2 == 0]\nprint(even_squares)  # [4, 16, 36, 64, 100]\n\n# Nested loops\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nflattened = [num for row in matrix for num in row]\nprint(flattened)  # [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# Dictionary comprehensions\nwords = ['hello', 'world', 'python', 'programming']\nword_lengths = {word: len(word) for word in words}\nprint(word_lengths)  # {'hello': 5, 'world': 5, 'python': 6, 'programming': 11}\n\n# Dictionary with condition\nlong_words = {word: len(word) for word in words if len(word) > 5}\nprint(long_words)  # {'python': 6, 'programming': 11}\n\n# Set comprehensions\nunique_lengths = {len(word) for word in words}\nprint(unique_lengths)  # {5, 6, 11}\n\n# Generator expressions (memory efficient)\nsquares_gen = (x**2 for x in numbers)\nprint(type(squares_gen))  # <class 'generator'>\nprint(list(squares_gen))  # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n# Complex example with multiple conditions\nstudents = [\n    {'name': 'Alice', 'grade': 85, 'subject': 'Math'},\n    {'name': 'Bob', 'grade': 92, 'subject': 'Science'},\n    {'name': 'Charlie', 'grade': 78, 'subject': 'Math'},\n    {'name': 'Diana', 'grade': 96, 'subject': 'Science'}\n]\n\n# High achievers in Science\nhigh_science = [s['name'] for s in students \n               if s['subject'] == 'Science' and s['grade'] > 90]\nprint(high_science)  # ['Bob', 'Diana']\n\n# Grade mapping\ngrade_map = {s['name']: 'A' if s['grade'] >= 90 else 'B' if s['grade'] >= 80 else 'C' \n             for s in students}\nprint(grade_map)  # {'Alice': 'B', 'Bob': 'A', 'Charlie': 'C', 'Diana': 'A'}\n\n# Conditional expressions in comprehensions\nresults = [x if x > 0 else 0 for x in [-2, -1, 0, 1, 2]]\nprint(results)  # [0, 0, 0, 1, 2]\n\n# Performance comparison with traditional loops\nimport time\n\n# Traditional loop\nstart = time.time()\ntraditional = []\nfor i in range(1000000):\n    if i % 2 == 0:\n        traditional.append(i**2)\nloop_time = time.time() - start\n\n# List comprehension\nstart = time.time()\ncomprehension = [i**2 for i in range(1000000) if i % 2 == 0]\ncomp_time = time.time() - start\n\nprint(f\"Loop time: {loop_time:.4f}s\")\nprint(f\"Comprehension time: {comp_time:.4f}s\")\n```",
    "context": "Python data structures and functional programming",
    "type": "TECHNICAL",
    "programming_language": "python",
    "difficulty": "intermediate",
    "tags": [
      "comprehensions",
      "list-comprehension",
      "dict-comprehension",
      "generators",
      "functional-programming"
    ]
  },
  {
    "id": "python-20",
    "question": "Explain Python's import system and different ways to import modules.",
    "answer": "Python's import system allows you to use code from other modules and packages in your program. Understanding the different import methods and their implications is crucial for writing maintainable code.\n\n**Types of imports:**\n- import module: Imports entire module\n- from module import name: Imports specific names\n- from module import *: Imports all public names (discouraged)\n- import module as alias: Imports with custom name\n- Relative imports: Used within packages\n\n**Import process:**\n1. Python checks sys.modules cache\n2. Searches for module in sys.path\n3. Loads and executes module code\n4. Creates module object and adds to sys.modules\n\n**Best practices:**\n- Use specific imports when possible\n- Avoid wildcard imports (from module import *)\n- Group imports: standard library, third-party, local\n- Use absolute imports over relative imports\n\n```python\n# Different import methods\n\n# 1. Basic import\nimport math\nprint(math.pi)  # 3.141592653589793\nprint(math.sqrt(16))  # 4.0\n\n# 2. Import with alias\nimport numpy as np\n# arr = np.array([1, 2, 3])\n\n# 3. Import specific functions/classes\nfrom math import pi, sqrt, sin\nprint(pi)  # 3.141592653589793\nprint(sqrt(25))  # 5.0\n\n# 4. Import with alias for specific items\nfrom datetime import datetime as dt\nnow = dt.now()\nprint(now)\n\n# 5. Multiple imports from same module\nfrom os import path, environ, getcwd\nprint(getcwd())\n\n# 6. Import all (not recommended)\n# from math import *  # Pollutes namespace\n\n# 7. Conditional imports\ntry:\n    import matplotlib.pyplot as plt\n    HAS_MATPLOTLIB = True\nexcept ImportError:\n    HAS_MATPLOTLIB = False\n    print(\"Matplotlib not available\")\n\n# 8. Dynamic imports\nimport importlib\n\nmodule_name = \"json\"\nmodule = importlib.import_module(module_name)\ndata = module.loads('{\"key\": \"value\"}')\nprint(data)  # {'key': 'value'}\n\n# 9. Import from packages\n# from mypackage.submodule import MyClass\n# from mypackage import submodule\n\n# 10. Relative imports (within packages)\n# from . import sibling_module\n# from .. import parent_module\n# from ..sibling_package import module\n\n# Understanding sys.path and module search\nimport sys\nprint(\"Python path:\")\nfor path in sys.path[:3]:  # Show first 3 paths\n    print(f\"  {path}\")\n\n# Check loaded modules\nimport sys\nprint(f\"Number of loaded modules: {len(sys.modules)}\")\nprint(\"Some loaded modules:\", list(sys.modules.keys())[:5])\n\n# Module introspection\nimport inspect\nprint(f\"Math module file: {inspect.getfile(math)}\")\nprint(f\"Math module members: {len(inspect.getmembers(math))}\")\n\n# Creating and importing custom module programmatically\nimport types\n\n# Create a module object\ncustom_module = types.ModuleType(\"custom\")\ncustom_module.greeting = \"Hello from custom module!\"\ncustom_module.add = lambda x, y: x + y\n\n# Add to sys.modules\nsys.modules[\"custom\"] = custom_module\n\n# Now we can import it\nimport custom\nprint(custom.greeting)  # Hello from custom module!\nprint(custom.add(3, 4))  # 7\n\n# Import best practices example\n# Standard library imports\nimport os\nimport sys\nfrom datetime import datetime, timedelta\n\n# Third-party imports\n# import requests\n# import numpy as np\n# import pandas as pd\n\n# Local application imports\n# from myapp.models import User\n# from myapp.utils import helper_function\n```",
    "context": "Python module system and code organization",
    "type": "TECHNICAL",
    "programming_language": "python",
    "difficulty": "intermediate",
    "tags": ["imports", "modules", "packages", "namespace", "code-organization"]
  }
]