[
  {
    "id": "react-1",
    "question": "¿Cuál es la principal diferencia entre componentes funcionales y de clase en React?",
    "answer": "Los **Componentes Funcionales** son simplemente funciones de JavaScript que aceptan props y devuelven JSX. Con la introducción de **Hooks** (React 16.8+), son la forma preferida de escribir componentes ya que pueden manejar estado y efectos secundarios, siendo más concisos y fáciles de probar.\n\nLos **Componentes de Clase** son clases ES6 que extienden `React.Component` y requieren un método `render()`. Manejan el estado a través de `this.state` y el ciclo de vida a través de métodos como `componentDidMount`.\n\n**Ejemplo de Estado (Funcional vs. Clase):**\n\n```jsx\n// Funcional (con Hooks)\nimport React, { useState } from 'react';\nconst MyFunctionalComp = ({ name }) => {\n  const [count, setCount] = useState(0);\n  return <button onClick={() => setCount(count + 1)}>{name}: {count}</button>;\n};\n\n// Clase (Legado)\nimport React, { Component } from 'react';\nclass MyClassComp extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n  render() {\n    return (\n      <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n        {this.props.name}: {this.state.count}\n      </button>\n    );\n  }\n}\n```",
    "context": "React Componentes",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["components", "hooks", "class-components", "functional-components"]
  },
  {
    "id": "react-2",
    "question": "¿Qué es el Virtual DOM y cómo funciona en React?",
    "answer": "El **Virtual DOM (VDOM)** es una abstracción ligera del DOM real mantenida en memoria. Es un objeto de JavaScript que mapea el DOM.\n\n**Flujo de funcionamiento:**\n1.  Cuando el estado o las props de un componente cambian, React crea un **nuevo VDOM-tree**.\n2.  Utiliza un algoritmo de **diffing** para comparar el nuevo VDOM con el VDOM anterior.\n3.  Identifica el conjunto mínimo de cambios necesarios para actualizar el DOM real.\n4.  React actualiza de manera eficiente **solo esas partes** del DOM real, minimizando las costosas manipulaciones directas del DOM del navegador.",
    "context": "React Fundamentos",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["virtual-dom", "performance", "rendering"]
  },
  {
    "id": "react-3",
    "question": "¿Qué son los 'Props' en React y cuál es su regla de oro?",
    "answer": "Las **Props** (Properties) son un mecanismo para pasar datos de un componente padre a un componente hijo, fluyendo siempre en una dirección, de arriba hacia abajo.\n\nLa regla de oro es que las **Props son inmutables ('read-only')**. Un componente nunca debe modificar sus propias props.\n\n**Ejemplo:**\n\n```jsx\n// Componente Padre\nconst App = () => {\n  const username = \"Alice\";\n  return <WelcomeMessage user={username} greeting=\"Hello\" />;\n};\n\n// Componente Hijo: Accede a 'user' y 'greeting' a través de props\nconst WelcomeMessage = (props) => {\n  return <h1>{props.greeting}, {props.user}!</h1>;\n  // Error: props.user = \"Bob\"; // No permitido, las props son read-only\n};\n```",
    "context": "React Componentes",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["props", "data-flow", "immutability"]
  },
  {
    "id": "react-4",
    "question": "¿Qué es el 'Estado' (`State`) en React y cómo se gestiona en un componente funcional?",
    "answer": "El **Estado** (`State`) es la fuente de verdad privada de un componente para los datos que deben cambiar con el tiempo. Cuando el estado cambia, el componente se **re-renderiza**.\n\nEn componentes funcionales, el estado se gestiona con el Hook **`useState`**, que devuelve el valor del estado actual y una función para actualizarlo:\n\n**Ejemplo con `useState`:**\n\n```jsx\nimport React, { useState } from 'react';\n\nconst Counter = () => {\n  // [estado actual, función actualizadora] = useState(valor inicial)\n  const [count, setCount] = useState(0);\n\n  const increment = () => {\n    // Mejor práctica: usar una función si la nueva actualización depende del estado anterior\n    setCount(prevCount => prevCount + 1);\n  };\n\n  return <button onClick={increment}>Count: {count}</button>;\n};\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["state", "hooks", "usestate"]
  },
  {
    "id": "react-5",
    "question": "¿Qué son los Hooks y nombra algunos de los más comunes?",
    "answer": "Los **Hooks** son funciones especiales introducidas en React 16.8 que permiten a los desarrolladores \"engancharse\" (hook into) al estado y a las características del ciclo de vida de React desde **componentes funcionales**.\n\n**Reglas de los Hooks:**\n1.  Solo se llaman en el nivel superior de una función de componente de React.\n2.  Solo se llaman desde funciones de componentes de React o desde Custom Hooks.\n\n**Hooks comunes:**\n- **`useState`**: Para añadir estado local.\n- **`useEffect`**: Para manejar efectos secundarios (Data fetching, suscripciones, manipulación de DOM).\n- **`useContext`**: Para acceder al contexto de React.\n- **`useReducer`**: Alternativa a `useState` para estados más complejos.\n- **`useRef`**: Para referenciar elementos del DOM o almacenar valores mutables que no disparen renderizado.\n- **`useCallback`, `useMemo`**: Para optimización de rendimiento (memoización).",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["hooks", "usestate", "useeffect", "functional-components"]
  },
  {
    "id": "react-6",
    "question": "¿Explica el propósito del Hook `useEffect`?",
    "answer": "El Hook **`useEffect`** te permite realizar **efectos secundarios** (side effects) en componentes funcionales. Un 'efecto secundario' es cualquier cosa que interactúa con el mundo exterior o es asíncrona, como:\n\n- Obtención de datos (`Data fetching`).\n- Suscripciones (ej. eventos del navegador).\n- Manipulación del DOM.\n\n**Firma:** `useEffect(setup, dependencies)`\n\n**Ejemplo (Fetching de Datos):**\n\n```jsx\nimport React, { useState, useEffect } from 'react';\n\nconst UserProfile = ({ userId }) => {\n  const [user, setUser] = useState(null);\n\n  useEffect(() => {\n    // El efecto se ejecuta después de que el componente se renderiza\n    fetch(`/api/users/${userId}`)\n      .then(res => res.json())\n      .then(data => setUser(data));\n      \n    // El array de dependencias [userId] indica que el efecto debe re-ejecutarse\n    // solo si la prop `userId` cambia entre renderizados.\n  }, [userId]); \n\n  // ...\n};\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["useeffect", "side-effects", "lifecycle", "hooks"]
  },
  {
    "id": "react-7",
    "question": "¿Qué es la 'prop drilling' y cómo se puede evitar?",
    "answer": "El **Prop Drilling** (o 'perforación de props') es el proceso de pasar datos desde un componente a través de componentes intermedios que no necesitan esos datos, solo para que el componente más profundo de la jerarquía pueda acceder a ellos.\n\n**Cómo evitarlo:**\n\n1.  **React Context:** Es la forma nativa de React para pasar datos \"globales\" o específicos de un subárbol, permitiendo que cualquier componente anidado los consuma directamente sin pasar props manualmente.\n2.  **Librerías de Gestión de Estado:** Usar soluciones como Redux, Zustand, o Recoil para almacenar el estado en un lugar centralizado, al que cualquier componente puede suscribirse.\n3.  **Composición:** Reestructurar los componentes para que el componente padre pase el elemento que necesita los datos como un `prop` (ej. `children`), delegando la renderización al hijo directo, en lugar de pasar las props a través de varios niveles.",
    "context": "React Arquitectura",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["prop-drilling", "context", "architecture", "state-management"]
  },
  {
    "id": "react-8",
    "question": "¿Para qué sirve el Hook `useContext`?",
    "answer": "El Hook **`useContext`** se utiliza para consumir el valor del Contexto de React dentro de un componente funcional. Simplifica el acceso a datos compartidos por un `Context.Provider` sin necesidad de envolver el componente con un `Context.Consumer`.\n\n**Ejemplo de Consumo de Contexto:**\n\n```jsx\n// 1. Crear Contexto (en un archivo separado)\nexport const ThemeContext = createContext('light');\n\n// 2. Consumir el Contexto\nimport { ThemeContext } from './ThemeContext';\nimport React, { useContext } from 'react';\n\nconst ThemedButton = () => {\n  // Obtiene el valor 'light' o 'dark' del Provider más cercano\n  const theme = useContext(ThemeContext);\n  \n  return <button className={theme}>Click Me</button>;\n};\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["usecontext", "context", "state-management", "hooks"]
  },
  {
    "id": "react-9",
    "question": "¿Cuál es la función del Hook `useMemo` y el Hook `useCallback`?",
    "answer": "Ambos Hooks se utilizan para **optimizar el rendimiento** mediante la técnica de **memoización** (almacenamiento en caché de resultados):\n\n- **`useMemo`**: **Memoiza un valor**. Se usa para evitar recálculos costosos. Solo se vuelve a calcular el valor si alguna de sus dependencias ha cambiado. Retorna el **valor** memoizado.\n- **`useCallback`**: **Memoiza una función de callback**. Se usa para evitar que una función se redefina en cada renderizado. Esto es crucial cuando se pasan funciones a componentes hijos optimizados con `React.memo`, ya que una función no memoizada haría que el hijo se re-renderizara innecesariamente. Retorna la **función** memoizada.\n\n**Ejemplo `useCallback`:**\n\n```jsx\nconst ParentComponent = ({ itemId }) => {\n  // La función handleSave solo se crea una vez, a menos que cambie itemId.\n  const handleSave = useCallback(() => {\n    // Lógica para guardar usando itemId\n    console.log(`Guardando ítem ${itemId}`);\n  }, [itemId]);\n\n  // ChildComponent solo se re-renderiza si sus props cambian (incluyendo handleSave)\n  return <OptimizedChild onSave={handleSave} />;\n};\n\n// OptimizedChild usa React.memo para evitar re-renderizados innecesarios\nconst OptimizedChild = React.memo(({ onSave }) => { /* ... */ });\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["usememo", "usecallback", "memoization", "performance", "hooks"]
  },
  {
    "id": "react-10",
    "question": "¿Qué es la 'key' en las listas de React y por qué es importante?",
    "answer": "La **`key`** es un atributo especial que debe ser incluido al crear listas de elementos en React (típicamente al mapear un array). La `key` debe ser un string o un número que **identifique de forma única y estable** a cada elemento entre sus hermanos.\n\n**Importancia:** La `key` ayuda al algoritmo de diffing de React a identificar qué elementos han cambiado, se han añadido o se han eliminado. Sin keys únicas y estables, React no puede garantizar que el estado interno del componente (como los valores de un campo de formulario o el estado de un componente hijo) se mantenga correctamente cuando la lista es reordenada o modificada. **Usar el índice del array como `key` debe evitarse si la lista puede cambiar de orden.**\n\n**Ejemplo:**\n\n```jsx\nconst MyList = ({ items }) => (\n  <ul>\n    {items.map(item => (\n      // Usar un ID único de la fuente de datos es la mejor práctica\n      <ListItem key={item.id} data={item} />\n    ))}\n  </ul>\n);\n```",
    "context": "React Fundamentos",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["keys", "lists", "performance", "rendering"]
  },
  {
    "id": "react-11",
    "question": "¿Qué es la inmutabilidad y por qué es importante en React?",
    "answer": "La **inmutabilidad** significa que un objeto o valor no puede ser modificado después de su creación. En React, es esencial para el **estado** (`state`) y las **props**.\n\n**Importancia para el Estado:** React se basa en la inmutabilidad para saber cuándo un componente necesita re-renderizarse. Cuando se actualiza el estado, debes devolver un **nuevo objeto o array**, en lugar de modificar el existente (mutarlo). Si mutas un objeto de estado directamente, React podría pensar que la referencia al objeto es la misma y no detectar el cambio, lo que resulta en un re-renderizado incorrecto o nulo.\n\n**Ejemplo (Forma Incorrecta vs. Correcta):**\n\n```javascript\n// ESTADO: { user: { name: 'Alice', age: 30 } }\n\n// ❌ Forma INCORRECTA (Mutación directa - React no detectará el cambio)\nconst updateUserError = (currentUser) => {\n  currentUser.user.age = 31;\n  // setState(currentUser) falla si el objeto no ha cambiado su referencia\n  return currentUser;\n};\n\n// ✅ Forma CORRECTA (Inmutabilidad con Spread Operator)\nconst updateUserCorrect = (currentUser) => {\n  return {\n    ...currentUser, // Copia el resto del estado\n    user: {\n      ...currentUser.user, // Copia el sub-objeto 'user'\n      age: 31 // Sobrescribe solo 'age'\n    }\n  };\n  // setState(newObject) asegura que React detecta el cambio de referencia\n};\n```",
    "context": "React Fundamentos",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["immutability", "state", "props", "performance"]
  },
  {
    "id": "react-12",
    "question": "¿Cuál es el propósito del Hook `useReducer`?",
    "answer": "El Hook **`useReducer`** es una alternativa a `useState` para la gestión de estado. Es más adecuado cuando el estado es **complejo** (es un objeto o array con muchas sub-propiedades) o cuando las actualizaciones de estado dependen del estado anterior de manera intrincada.\n\n`useReducer` acepta una **función reductora** (`reducer`) y un estado inicial, y devuelve el estado actual y una función `dispatch`. Esto centraliza la lógica de actualización de estado (el *reducer*) fuera del componente, promoviendo la claridad y la capacidad de prueba, siguiendo un patrón similar al de Redux.\n\n**Firma:** `const [state, dispatch] = useReducer(reducer, initialState);`\n\n**Ejemplo (Reducer):**\n\n```javascript\nconst todoReducer = (state, action) => {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return [...state, action.payload];\n    case 'TOGGLE_TODO':\n      return state.map(todo => \n        todo.id === action.id ? { ...todo, completed: !todo.completed } : todo\n      );\n    default:\n      return state;\n  }\n};\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["usereducer", "state-management", "hooks"]
  },
  {
    "id": "react-13",
    "question": "¿Cómo se manejan las peticiones HTTP (data fetching) en un componente funcional?",
    "answer": "Las peticiones HTTP son un **efecto secundario** y se manejan dentro del Hook **`useEffect`**.\n\n**Patrón de Data Fetching con `useEffect`:**\n\n1.  Define una función asíncrona dentro del callback de `useEffect` (o usa una función auto-ejecutable, o define la función fuera).\n2.  Incluye una **función de limpieza** (`return` de `useEffect`) para **cancelar la petición o ignorar la respuesta** si el componente se desmonta o el efecto se re-ejecuta antes de que la promesa se resuelva (evitando fugas de memoria y *race conditions*).\n3.  Usa el array de dependencias (`[]`) para controlar cuándo se vuelve a ejecutar la petición (típicamente solo en el montaje inicial).\n\n**Ejemplo (con Limpieza):**\n\n```jsx\nuseEffect(() => {\n  let isSubscribed = true; // Bandera para la limpieza\n\n  const fetchData = async () => {\n    const response = await fetch('/api/data');\n    const data = await response.json();\n\n    if (isSubscribed) {\n      setState(data);\n    }\n  };\n\n  fetchData();\n\n  return () => { \n    // Función de limpieza\n    isSubscribed = false; \n  };\n}, []); // Array vacío: se ejecuta solo en el montaje\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["data-fetching", "useeffect", "side-effects", "api"]
  },
  {
    "id": "react-14",
    "question": "¿Qué es la 'composición de componentes' en React?",
    "answer": "La **Composición de Componentes** es el principio fundamental de React de construir aplicaciones a partir de componentes pequeños, independientes y reutilizables.\n\nReact fomenta la composición sobre la herencia. Hay dos tipos comunes:\n\n1.  **Composición por Contención:** Cuando un componente es un \"contenedor\" y no sabe de antemano lo que contendrá. Utiliza el prop especial **`children`** para renderizar el contenido pasado entre sus etiquetas.\n\n    ```jsx\n    // Componente Contenedor\n    const Card = ({ children }) => (\n      <div className=\"card-box\">\n        {children}\n      </div>\n    );\n    \n    // Uso\n    <Card><p>Contenido flexible aquí.</p></Card>\n    ```\n\n2.  **Composición por Especialización:** Cuando un componente renderiza otro y lo configura con props (ej. un `ButtonPrimary` que renderiza un `Button` con un `type='primary'` establecido).",
    "context": "React Arquitectura",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["composition", "architecture", "children", "reusability"]
  },
  {
    "id": "react-15",
    "question": "¿Cómo se utiliza el Hook `useRef`?",
    "answer": "El Hook **`useRef`** se utiliza para dos propósitos principales, ya que devuelve un objeto mutable cuya propiedad `.current` se inicializa con el argumento pasado:\n\n1.  **Acceder al DOM:** Obtener una referencia directa a un elemento DOM (es decir, el elemento HTML subyacente).\n2.  **Almacenar un valor mutable:** Mantener cualquier valor que necesite persistir a través de los re-renderizados sin causar que el componente se re-renderice cuando cambia (a diferencia de `useState`).\n\n**Ejemplo de Acceso al DOM:**\n\n```jsx\nimport React, { useRef } from 'react';\n\nconst TextInput = () => {\n  const inputRef = useRef(null);\n\n  const focusInput = () => {\n    // Accede al elemento DOM subyacente (el <input>)\n    inputRef.current.focus();\n  };\n\n  return (\n    <>\n      <input ref={inputRef} type=\"text\" />\n      <button onClick={focusInput}>Focus Input</button>\n    </>\n  );\n};\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["useref", "dom", "refs", "hooks"]
  },
  {
    "id": "react-16",
    "question": "¿Qué es `React.memo` y cuándo se debe usar?",
    "answer": "**`React.memo`** es un Higher-Order Component (HOC) que se utiliza para **optimizar el rendimiento** de **componentes funcionales**.\n\nActúa como una \"puerta\" de renderizado: si las props recibidas por un componente son las mismas que en la renderización anterior, React omite el re-renderizado de ese componente y reutiliza el resultado memoizado (cached).\n\n**Cuándo usarlo:** Cuando un componente:\n1.  Se re-renderiza con frecuencia.\n2.  Recibe las mismas props la mayoría de las veces.\n3.  El re-renderizado es costoso (lento).\n\n**Nota:** Para componentes hijos memoizados, es crucial usar `useCallback` o `useMemo` para sus props de función/objeto, de lo contrario, React las verá como 'cambiadas' en cada renderizado del padre.\n\n**Ejemplo:**\n\n```jsx\nconst MyComponent = ({ propA, propB }) => { /* ... */ };\n\n// Ahora, MyOptimizedComponent solo se re-renderiza si propA o propB cambian\nconst MyOptimizedComponent = React.memo(MyComponent);\n```",
    "context": "React Performance",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["react.memo", "performance", "memoization", "hoc"]
  },
  {
    "id": "react-17",
    "question": "¿Qué es un 'Higher-Order Component' (HOC)?",
    "answer": "Un **Higher-Order Component (HOC)** es una técnica avanzada para la reutilización de lógica en React. Un HOC es una **función** que toma un componente como argumento y devuelve un **nuevo componente** mejorado (envuelto) con lógica, datos o funcionalidad adicionales.\n\n**Firma:** `const NewComponent = higherOrderComponent(OriginalComponent);`\n\n**Caso de uso:** Compartir lógica no visual (ej. gestión de suscripciones, lógica de carga de datos, manejo de autenticación).\n\n**Ejemplo (Conceptual):**\n\n```javascript\n// HOC que inyecta una propiedad 'isLoading'\nconst withLoading = (WrappedComponent) => {\n  return class WithLoading extends React.Component {\n    state = { isLoading: true };\n    componentDidMount() { \n      // Simula fetch de datos\n      setTimeout(() => this.setState({ isLoading: false }), 1000);\n    }\n    render() {\n      if (this.state.isLoading) return <div>Cargando...</div>;\n      // Pasa todas las props originales más la lógica extra\n      return <WrappedComponent {...this.props} isLoading={this.state.isLoading} />;\n    }\n  };\n};\n\n// Uso del HOC\nconst EnhancedList = withLoading(UserList);\n```",
    "context": "React Arquitectura",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "advanced",
    "tags": ["hoc", "patterns", "reusability", "architecture"]
  },
  {
    "id": "react-18",
    "question": "¿Cómo se maneja el enrutamiento en una aplicación React?",
    "answer": "El enrutamiento del lado del cliente se maneja típicamente usando la librería **React Router (v6+).** Esta librería utiliza la History API del navegador para mantener la interfaz de usuario (UI) sincronizada con la URL.\n\n**Conceptos clave (React Router v6):**\n- **`BrowserRouter`**: El componente que envuelve toda la aplicación y proporciona el contexto de enrutamiento.\n- **`Routes`**: Un contenedor donde se definen todas las posibles rutas.\n- **`Route`**: Se utiliza para mapear una ruta URL (`path`) con el componente que debe renderizarse (`element`).\n- **`Link`**: Un componente para la navegación declarativa que evita la recarga completa de la página.\n- **`useNavigate`, `useParams`**: Hooks para la navegación programática y la lectura de parámetros de la URL, respectivamente.\n\n**Ejemplo (React Router v6):**\n\n```jsx\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\n\nconst App = () => (\n  <BrowserRouter>\n    <Routes>\n      <Route path=\"/\" element={<HomePage />} />\n      <Route path=\"/users/:userId\" element={<UserProfile />} />\n      <Route path=\"*\" element={<NotFoundPage />} />\n    </Routes>\n  </BrowserRouter>\n);\n```",
    "context": "React Tooling",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["react-router", "routing", "hooks"]
  },
  {
    "id": "react-19",
    "question": "¿Qué son los 'Synthetic Events' en React?",
    "answer": "Los **Synthetic Events** (Eventos Sintéticos) son un envoltorio (`wrapper`) de React alrededor del sistema de eventos nativos del navegador.\n\n**Propósito y Características:**\n1.  **Normalización:** Proporcionan una API de eventos consistente y normalizada en todos los navegadores, eliminando las preocupaciones de compatibilidad (por ejemplo, `event.target` funciona igual en todos).\n2.  **Pool de Eventos (Obsoleto):** En versiones anteriores de React, los objetos de evento se reutilizaban por razones de rendimiento. Aunque esto ya no sucede en React 17+, la recomendación de no acceder al objeto `event` de forma asíncrona (a menos que lo extraigas primero) sigue siendo relevante en la mayoría de los casos de uso para evitar sorpresas.",
    "context": "React Fundamentos",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["events", "synthetic-events", "dom", "performance"]
  },
  {
    "id": "react-20",
    "question": "¿Explica qué son y cómo se utilizan las 'Fragments' (`<>` o `<React.Fragment>`)?",
    "answer": "Los **Fragments** son un componente especial que te permite agrupar una lista de elementos hijos **sin añadir un nodo adicional al DOM** (es decir, sin un `div` envolvente innecesario).\n\n**Propósito:** Son cruciales para mantener una semántica HTML válida (por ejemplo, al renderizar celdas de una tabla donde el padre *debe* ser un `<tr>`) o al trabajar con estructuras CSS como Flexbox o Grid, donde un `div` envolvente podría romper el diseño.\n\n**Sintaxis:**\n\n```jsx\n// Sintaxis Larga\nimport React, { Fragment } from 'react';\n<Fragment>\n  <td>Columna 1</td>\n  <td>Columna 2</td>\n</Fragment>\n\n// Sintaxis Corta (más común)\n<>\n  <Header />\n  <Content />\n</>\n// NOTA: La sintaxis corta no admite el atributo 'key'.\n```",
    "context": "React Fundamentos",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["fragments", "jsx", "dom"]
  },
  {
    "id": "react-21",
    "question": "¿Qué es la 'render props' pattern?",
    "answer": "El patrón **Render Props** es una técnica para compartir código y lógica entre componentes de React. Un componente con un 'render prop' toma una **función** como prop (a menudo llamada `render` o `children`) y llama a esa función para determinar qué renderizar, pasándole datos o lógica como argumento.\n\n**Ventaja:** Permite que el componente padre (el que implementa la lógica) inyecte datos o comportamiento en el componente hijo, delegando la renderización de la UI completamente al consumidor.\n\n**Ejemplo (Componente que implementa el patrón):**\n\n```jsx\nconst MouseTracker = ({ render }) => {\n  const [coords, setCoords] = useState({ x: 0, y: 0 });\n  // ... (Lógica para manejar el evento onMouseMove)\n\n  // Llama a la prop 'render' y le pasa el estado\n  return <div>{render(coords)}</div>;\n};\n\n// Uso por el Consumidor:\n<MouseTracker render={mouse => (\n  <h1>Posición del ratón: ({mouse.x}, {mouse.y})</h1>\n)} />\n```",
    "context": "React Arquitectura",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "advanced",
    "tags": ["patterns", "render-props", "reusability"]
  },
  {
    "id": "react-22",
    "question": "¿Cuándo debes elegir entre `useMemo` y `useCallback`?",
    "answer": "La elección depende de si estás memoizando un **valor** o una **función**:\n\n| Hook | Propósito Principal | Retorno | Dependencias Comunes | Uso Típico |\n| :--- | :--- | :--- | :--- | :--- |\n| **`useMemo`** | Evitar recálculos costosos de un valor. | El **valor** memoizado. | Variables de estado, props, resultados de funciones. | Filtrado de grandes arrays, cálculos matemáticos complejos. |\n| **`useCallback`** | Evitar la recreación de funciones. | La **función** memoizada. | Variables de estado, props utilizadas en la función. | Pasar funciones a componentes hijos memoizados (`React.memo`) para evitar re-renderizados innecesarios. |\n\n**Regla general:** Si el resultado es un valor primitivo, objeto o array, usa **`useMemo`**. Si el resultado es una función, usa **`useCallback`** (especialmente si se pasa como prop).",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["usememo", "usecallback", "performance", "hooks"]
  },
  {
    "id": "react-23",
    "question": "¿Qué es 'lifting state up' y por qué se hace?",
    "answer": "**Lifting State Up** (Elevar el Estado) es una técnica para compartir el estado o sincronizarlo entre dos o más componentes hermanos o que no tienen una relación padre-hijo directa. Consiste en mover el estado a su **ancestro común más cercano**.\n\n**Proceso:**\n1.  El estado se declara y mantiene en el componente ancestro (ej. `ParentComponent`).\n2.  El componente ancestro pasa los datos (estado) a los componentes hijos como **props**.\n3.  El componente ancestro pasa una **función de callback** a los hijos a través de props. Los hijos llaman a esta función para solicitar la actualización del estado al ancestro.\n\nEsto asegura que haya una **única fuente de verdad** para ese fragmento de datos, facilitando la sincronización y el flujo de datos unidireccional de React.",
    "context": "React Componentes",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["state", "data-flow", "architecture"]
  },
  {
    "id": "react-24",
    "question": "¿Cómo se prueba un componente de React? (Menciona herramientas y tipos de prueba)",
    "answer": "La prueba de componentes de React se divide en diferentes niveles:\n\n1.  **Pruebas Unitarias/De Componente (Testing Library/Jest):** Se centran en la unidad aislada. Se utiliza la **React Testing Library** (preferida) junto con **Jest** para renderizar componentes en un entorno DOM simulado y probar cómo se comporta el componente a través de la interacción simulada del usuario. La filosofía de Testing Library es: \"Prueba el componente de la misma manera que el usuario lo haría\".\n\n    ```javascript\n    // Ejemplo de Testing Library\n    import { render, screen } from '@testing-library/react';\n    import userEvent from '@testing-library/user-event';\n    \n    test('Button increments counter on click', async () => {\n      render(<Counter />);\n      const button = screen.getByText(/Count: 0/i);\n      await userEvent.click(button);\n      expect(screen.getByText(/Count: 1/i)).toBeInTheDocument();\n    });\n    ```\n\n2.  **Pruebas End-to-End (E2E) (Cypress/Playwright):** Prueban el flujo de usuario a través de la aplicación en un navegador real, cubriendo la integración de backend y frontend.",
    "context": "React Tooling",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["testing", "jest", "testing-library"]
  },
  {
    "id": "react-25",
    "question": "¿Qué es el 'Strict Mode' (`<React.StrictMode>`) y su propósito?",
    "answer": "**`React.StrictMode`** es una herramienta de desarrollo que se utiliza para destacar problemas potenciales en una aplicación. No renderiza ninguna UI visible y solo funciona en modo de desarrollo.\n\n**Propósito:** Activa comprobaciones y advertencias adicionales, incluyendo:\n-   Identificar componentes con efectos secundarios inseguros (ej. llama a `useEffect` dos veces para exponer problemas de limpieza).\n-   Advertir sobre el uso de APIs obsoletas de ciclo de vida de componentes de clase.\n-   Detectar el uso de la API de cadena de referencia obsoleta.\n-   Advertir sobre efectos secundarios inesperados en el proceso de renderizado (doble invocación de funciones de render y métodos de clase).",
    "context": "React Fundamentos",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["strictmode", "debugging", "development"]
  },
  {
    "id": "react-26",
    "question": "¿Cómo se maneja la optimización del rendimiento en la renderización de listas muy largas?",
    "answer": "Para optimizar listas muy largas (cientos o miles de elementos), se utiliza el concepto de **Virtualización** o **Windowing**.\n\n**Virtualización/Windowing:** Es una técnica que solo renderiza los elementos de la lista que son **visibles** para el usuario en la ventana (viewport) actual, más un pequeño número de elementos adyacentes. A medida que el usuario se desplaza, se crean y destruyen dinámicamente los elementos DOM necesarios.\n\n-   **Ventaja:** Reduce drásticamente la cantidad de nodos DOM que el navegador necesita manejar, mejorando significativamente el rendimiento de desplazamiento y el tiempo de carga.\n-   **Librerías Comunes:** **`react-window`** (más pequeña y enfocada) o **`react-virtualized`** (más completa) implementan esta lógica.",
    "context": "React Performance",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["performance", "lists", "virtualization"]
  },
  {
    "id": "react-27",
    "question": "¿Cuál es la principal diferencia entre Server-Side Rendering (SSR) y Client-Side Rendering (CSR)?",
    "answer": "| Característica | CSR (Client-Side Rendering - React Tradicional) | SSR (Server-Side Rendering - Next.js, etc.) |\n| :--- | :--- | :--- |\n| **HTML Inicial** | Se envía un HTML casi vacío (`<div id=\"root\"></div>`). | Se envía el HTML completo de la página. |\n| **Renderizado Inicial** | Ocurre en el **navegador** (cliente) después de que el JS se descarga. | Ocurre en el **servidor**. |\n| **Tiempo de Contenido** | El usuario ve una página en blanco o un spinner hasta que el JS se carga y se ejecuta. | El usuario ve el contenido inmediatamente (buen TTI). |\n| **SEO** | Puede ser un desafío para los rastreadores de motores de búsqueda que no ejecutan JS. | Excelente, el rastreador recibe contenido renderizado. |\n\nCon **SSR**, el HTML inicial es renderizado en el servidor y luego React \"hidrata\" ese HTML en el navegador para hacerlo interactivo.",
    "context": "React Arquitectura",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["ssr", "csr", "nextjs", "performance"]
  },
  {
    "id": "react-28",
    "question": "¿Qué es `JSX` y cómo se convierte en código que el navegador entiende?",
    "answer": "**JSX** (JavaScript XML) es una extensión de sintaxis de JavaScript que permite escribir estructuras de código similares a HTML dentro de archivos JavaScript. No es HTML ni un string, sino azúcar sintáctico.\n\n**Conversión (Transpilación):** El código JSX se convierte en llamadas a funciones de JavaScript estándar de React mediante un **transpilador** como **Babel**. Específicamente, transforma las etiquetas JSX en llamadas a `React.createElement()` (o `_jsx` en React 17+).\n\n**Ejemplo de Transpilación:**\n\n```jsx\n// Código JSX\nconst element = <h1 className=\"greeting\">Hello, world!</h1>;\n\n// Código JavaScript (Transpilado por Babel)\nconst element = React.createElement(\n  'h1',\n  { className: 'greeting' },\n  'Hello, world!'\n);\n```",
    "context": "React Fundamentos",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["jsx", "babel", "virtual-dom"]
  },
  {
    "id": "react-29",
    "question": "¿Cómo se define un Custom Hook y para qué sirve?",
    "answer": "Un **Custom Hook** es una función de JavaScript normal cuyo nombre **debe comenzar con el prefijo `use`** (por ejemplo, `useFetch`, `useLocalStorage`).\n\n**Propósito:** Sirve para **reutilizar lógica con estado** entre diferentes componentes funcionales sin compartir la interfaz de usuario. Permite aislar lógica compleja (gestión de formularios, manejo de timers, lógica de suscripción a APIs) en una función reusable.\n\n**Ejemplo (`useToggle`):**\n\n```javascript\n// custom hook\nconst useToggle = (initialValue = false) => {\n  const [value, setValue] = useState(initialValue);\n\n  const toggle = useCallback(() => {\n    setValue(currentValue => !currentValue);\n  }, []);\n\n  return [value, toggle];\n};\n\n// Uso en un componente\nconst MyComponent = () => {\n  const [isDarkMode, toggleDarkMode] = useToggle(false);\n  return <button onClick={toggleDarkMode}>Toggle Dark Mode</button>;\n};\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["custom-hooks", "hooks", "reusability", "architecture"]
  },
  {
    "id": "react-30",
    "question": "¿Qué son los 'Portals' en React?",
    "answer": "Un **Portal** es una forma de renderizar un componente hijo en un nodo DOM que **existe fuera de la jerarquía DOM del componente padre** que lo llama.\n\nSe utiliza la función **`ReactDOM.createPortal(child, container)`**.\n\n**Caso de uso común:** Son ideales para modales, tooltips, notificaciones o menús flotantes, ya que permiten que el componente se renderice directamente en un lugar como `document.body`. Esto soluciona problemas de estilo (como `z-index`, `overflow: hidden`, o `position: relative`) que el componente padre podría imponer, permitiendo que el elemento hijo se muestre correctamente en la parte superior de todo.",
    "context": "React Advanced",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "advanced",
    "tags": ["portals", "dom", "rendering"]
  },
  {
    "id": "react-31",
    "question": "¿Cómo se utiliza el Hook `useLayoutEffect` y en qué se diferencia de `useEffect`?",
    "answer": "- **`useEffect`**: Se ejecuta **asíncronamente** después de que el navegador ha pintado (repintado) el DOM (después de la renderización).\n- **`useLayoutEffect`**: Es idéntico a `useEffect` en su firma, pero se dispara **sincrónicamente** inmediatamente después de que React ha realizado las mutaciones del DOM, pero **antes** de que el navegador pinte el resultado en pantalla.\n\n**Cuándo usar `useLayoutEffect`:** Cuando necesitas medir el DOM, o realizar modificaciones del DOM que podrían cambiar el diseño o la posición, y quieres que esos cambios sean visibles **antes** de que el usuario vea la primera pintura. Si usas `useEffect` en estos casos, el usuario podría ver un \"parpadeo\" visual antes de que se aplique la corrección. Usarlo con moderación ya que bloquea la pintura del navegador.\n\n**Ejemplo (Medición y Ajuste):**\n\n```jsx\nconst Tooltip = () => {\n  const ref = useRef();\n  \n  useLayoutEffect(() => {\n    // Mide la posición del elemento después del renderizado\n    const { width } = ref.current.getBoundingClientRect();\n    // Ajusta la posición (cambia el estilo) inmediatamente, antes de que el navegador pinte\n    // ...\n  }, []);\n  return <div ref={ref}>...</div>;\n};\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "advanced",
    "tags": ["useeffect", "uselayouteffect", "dom", "hooks"]
  },
  {
    "id": "react-32",
    "question": "¿Cómo se hace una llamada a la API que se vuelve a ejecutar solo cuando cambia un `userId`?",
    "answer": "Se utiliza el Hook **`useEffect`** y se incluye la variable `userId` en su **array de dependencias**.\n\nAl incluir `[userId]`, React garantiza que:\n1.  El efecto se ejecute después del montaje inicial.\n2.  El efecto se ejecute **solo** si el valor de `userId` ha cambiado desde la última renderización.\n\n**Ejemplo Detallado (con Limpieza y Dependencias):**\n\n```jsx\nimport React, { useState, useEffect } from 'react';\n\nfunction UserProfile({ userId }) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n\n  useEffect(() => {\n    let isSubscribed = true; // Bandera de limpieza\n    setLoading(true);\n    setData(null);\n\n    fetch(`/api/users/${userId}`)\n      .then(res => res.json())\n      .then(newData => {\n        if (isSubscribed) {\n          setData(newData);\n          setLoading(false);\n        }\n      })\n      .catch(error => {\n        if (isSubscribed) console.error(error);\n      });\n\n    return () => {\n      // Limpieza: previene que la respuesta asíncrona actualice un estado obsoleto/desmontado\n      isSubscribed = false;\n    };\n  }, [userId]); // <--- Dependencia clave\n\n  if (loading) return <div>Cargando usuario {userId}...</div>;\n  return <div>{/* ... Render data ... */}</div>;\n}\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["useeffect", "data-fetching", "hooks", "dependencies"]
  },
  {
    "id": "react-33",
    "question": "¿Qué es 'Redux' y por qué se usa en una aplicación React?",
    "answer": "**Redux** es una librería de JavaScript para la **gestión de estado predecible**. Se utiliza para centralizar el estado global de una aplicación React. Proporciona un único contenedor de estado (`store`) que es la \"única fuente de verdad\".\n\n**Se usa para:**\n-   Manejar estado que necesita ser compartido por muchos componentes.\n-   Facilitar la depuración y el seguimiento de los cambios de estado a lo largo del tiempo (gracias a la inmutabilidad y Redux DevTools).\n\n**Ciclo de Redux (El \"Flujo Unidireccional\"):**\n1.  **View (React Component)**: Dispara una **Action** (un objeto JS simple que describe lo que pasó).\n2.  **Dispatch**: Envía la Action a la función **Reducer**.\n3.  **Reducer**: Es una función **pura** que toma el estado anterior y la Action, y devuelve un **nuevo objeto de estado** (siempre de forma inmutable).\n4.  **Store**: Almacena el nuevo estado, notifica a la View, y el componente React se re-renderiza con el nuevo estado.",
    "context": "State Management",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["redux", "state-management", "store", "architecture"]
  },
  {
    "id": "react-34",
    "question": "¿Qué son los 'Contextos' de React y cuándo se deben usar en lugar de Redux?",
    "answer": "La **API de Contexto** de React está diseñada para compartir datos considerados **\"globales\"** (como tema, idioma o información de usuario autenticado) a través de un subárbol de componentes sin tener que pasar props manualmente.\n\n**Contexto vs. Redux (o similar):**\n\n-   **Usa Contexto cuando:** El estado es simple, no cambia con mucha frecuencia y es local a una parte del árbol de componentes. Es ideal para evitar el *prop drilling* en escenarios de configuración y temas.\n-   **Usa Redux/Zustand cuando:** El estado es altamente complejo, cambia con frecuencia, y la aplicación requiere un sistema de gestión de efectos secundarios (middleware), herramientas de depuración avanzadas, y un historial de acciones de estado. Redux es más adecuado para estado de aplicación complejo y de alto tráfico.",
    "context": "React Context",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["context", "redux", "state-management", "usecontext"]
  },
  {
    "id": "react-35",
    "question": "¿Cuál es la sintaxis para pasar un componente como un prop `children`?",
    "answer": "La prop especial **`children`** se refiere al contenido que se pasa entre la apertura y el cierre de la etiqueta JSX de un componente. No se pasa como un prop explícito `children={...}` sino como contenido anidado.\n\n**Ejemplo:**\n\n```jsx\n// Componente Contenedor (Padre)\nconst Layout = ({ header, children }) => {\n  return (\n    <div className=\"layout\">\n      <header>{header}</header> {/* Renderiza el prop explícito 'header' */}\n      <main>{children}</main>   {/* Renderiza el contenido anidado */}\n    </div>\n  );\n};\n\n// Uso por el Consumidor\nconst Page = () => (\n  <Layout \n    header={<h2>Mi encabezado</h2>} // Prop explícita\n  >\n    {/* Este es el valor de la prop 'children' */}\n    <p>El cuerpo principal de la página.</p>\n    <Button text=\"Inicio\" />\n  </Layout>\n);\n```",
    "context": "React Componentes",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["composition", "children", "props"]
  },
  {
    "id": "react-36",
    "question": "¿Cómo se manejan los formularios y los 'controlled components' en React?",
    "answer": "Un **Controlled Component** (Componente Controlado) es un elemento de formulario de entrada (input, textarea, select) cuyo valor está completamente controlado por el **estado de React**.\n\n**Manejo:**\n1.  El valor del campo se establece a una variable de estado (`value={stateValue}`).\n2.  Se adjunta un manejador de eventos (`onChange`) que escucha los cambios del usuario y **actualiza el estado**.\n3.  La actualización de estado dispara un re-renderizado, y el valor del campo se actualiza con el nueva `stateValue`.\n\n**Ejemplo (Controlled Input):**\n\n```jsx\nconst MyForm = () => {\n  const [name, setName] = useState('');\n\n  const handleChange = (event) => {\n    // El valor del input es ahora el estado, y solo se actualiza vía React\n    setName(event.target.value);\n  };\n\n  return (\n    <input \n      type=\"text\"\n      value={name} // 1. El valor está atado al estado\n      onChange={handleChange} // 2. El cambio actualiza el estado\n    />\n  );\n};\n```",
    "context": "React Fundamentos",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["forms", "controlled-components", "state"]
  },
  {
    "id": "react-37",
    "question": "¿Qué son los 'uncontrolled components' y cuándo se utilizan?",
    "answer": "Un **Uncontrolled Component** (Componente No Controlado) es un elemento de formulario donde los datos son manejados por el **DOM mismo**, de la manera tradicional del HTML. React solo interviene cuando necesitas el valor (por ejemplo, al enviar el formulario).\n\n**Uso:** En lugar de un manejador `onChange`, se utiliza una **`ref`** para acceder al elemento DOM y obtener su valor actual (típicamente a través de `ref.current.value`).\n\n**Cuándo usarlos:**\n-   Para formularios o entradas simples donde no se necesita validación o retroalimentación instantánea, simplificando el código.\n-   A menudo utilizados con librerías externas de interfaz de usuario que manejan su propio estado DOM.\n\n**Ejemplo (Uncontrolled Input):**\n\n```jsx\nconst MyForm = () => {\n  const inputRef = useRef();\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    // El valor se lee directamente del DOM usando la ref\n    alert(`Submitted: ${inputRef.current.value}`);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input type=\"text\" ref={inputRef} defaultValue=\"Initial Value\" />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n};\n```",
    "context": "React Fundamentos",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["forms", "uncontrolled-components", "refs"]
  },
  {
    "id": "react-38",
    "question": "¿Cuál es la función del Hook `useImperativeHandle`?",
    "answer": "El Hook **`useImperativeHandle`** se utiliza para personalizar el **valor de instancia** que se expone a los componentes padre cuando usan una `ref` para acceder al componente hijo.\n\n**Uso:** Siempre se utiliza junto con **`forwardRef`** y sirve para exponer **solo las funciones o propiedades específicas** que quieres que el padre acceda, en lugar de toda la instancia del componente hijo (lo cual es una buena práctica de encapsulación).\n\n**Ejemplo:** Solo permite que el padre llame a la función `focus` del hijo.\n\n```jsx\nconst FancyInput = forwardRef((props, ref) => {\n  const inputRef = useRef();\n\n  useImperativeHandle(ref, () => ({\n    // El objeto retornado es lo que el padre verá como 'ref.current'\n    focus: () => {\n      inputRef.current.focus();\n    },\n    // Podrías añadir más métodos: clearValue: () => {...}\n  }));\n\n  return <input ref={inputRef} {...props} />;\n});\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "advanced",
    "tags": ["useimperativehandle", "forwardref", "refs", "hooks"]
  },
  {
    "id": "react-39",
    "question": "¿Cómo se maneja la accesibilidad (a11y) en React?",
    "answer": "React facilita la construcción de componentes accesibles adhiriéndose a los estándares de la web (WAI-ARIA). Las pautas clave incluyen:\n\n1.  **Semántica HTML:** Priorizar el uso de etiquetas HTML semánticas (`<button>`, `<nav>`, `<h1>`) en lugar de `div`s genéricos, ya que tienen significado inherente para los lectores de pantalla.\n2.  **Atributos `aria-`:** Utilizar atributos ARIA (ej. `aria-label`, `aria-hidden`, `role`) cuando los elementos HTML no transmiten la información necesaria sobre el estado o la función de la UI (ej. un `div` personalizado que actúa como botón).\n3.  **Manejo del Foco:** Asegurar que todos los elementos interactivos sean enfocables y operables con el teclado (usando `tabIndex` si es necesario, pero evitando si es posible).\n4.  **Fragments:** Para evitar añadir elementos DOM innecesarios que podrían interferir con la estructura semántica o de accesibilidad.\n\n**Ejemplo ARIA:**\n\n```jsx\n// Un componente de progreso que usa ARIA para comunicar su valor\nconst ProgressBar = ({ value }) => (\n  <div \n    role=\"progressbar\" // Indica que este elemento es una barra de progreso\n    aria-valuenow={value} // Indica el valor actual\n    aria-valuemin=\"0\"\n    aria-valuemax=\"100\"\n  >\n    {value}%\n  </div>\n);\n```",
    "context": "React Best Practices",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["a11y", "accessibility", "best-practices", "html"]
  },
  {
    "id": "react-40",
    "question": "¿Qué son los 'Error Boundaries' y cómo se implementan?",
    "answer": "Los **Error Boundaries** (Límites de Error) son componentes de React (solo de **clase**) que tienen la capacidad de:\n\n1.  **Capturar errores** de JavaScript en cualquier lugar dentro de su árbol de componentes descendiente (en los ciclos de vida, renderizado y constructores).\n2.  **Registrar** esos errores.\n3.  **Mostrar una interfaz de usuario de reserva** (`fallback UI`) en lugar del árbol de componentes que falló.\n\n**Métodos de Implementación Clave:**\n\n```jsx\nclass ErrorBoundary extends React.Component {\n  state = { hasError: false };\n\n  // 1. Se llama después de que un descendiente lanza un error. Actualiza el estado.\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n\n  // 2. Se utiliza para registrar información del error (ej. a un servicio de logging).\n  componentDidCatch(error, errorInfo) {\n    console.error(\"Uncaught error:\", error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <h1>Algo salió mal.</h1>; // Fallback UI\n    }\n    return this.props.children;\n  }\n}\n```\n\n**Nota:** No capturan errores dentro de manejadores de eventos o llamadas asíncronas (`setTimeout`, `fetch`).",
    "context": "React Advanced",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["error-boundaries", "error-handling", "lifecycle"]
  },
  {
    "id": "react-41",
    "question": "¿Cómo se resuelve un *race condition* en una llamada a API dentro de `useEffect`?",
    "answer": "Un *race condition* (condición de carrera) en `useEffect` ocurre cuando varias llamadas asíncronas se inician y se completan en un orden diferente al que se iniciaron (ej. el usuario cambia de pestaña rápidamente, la llamada lenta anterior se resuelve después de la rápida posterior, actualizando el estado incorrectamente).\n\nEsto se resuelve utilizando la **función de limpieza** del `useEffect` junto con una **bandera (`flag`)** para indicar si la respuesta actual debe ser ignorada, ya que una nueva petición ya fue iniciada (o el componente se desmontó).\n\n**Ejemplo (Técnica con bandera):**\n\n```jsx\nuseEffect(() => {\n  let isCurrent = true; // La bandera se inicializa a true\n\n  fetchData(userId).then(data => {\n    // Solo actualiza el estado si esta petición sigue siendo la \"más reciente\" y el componente sigue montado\n    if (isCurrent) {\n      setData(data);\n    }\n  });\n\n  return () => {\n    // La limpieza se ejecuta antes del siguiente efecto, marcando el anterior como obsoleto\n    isCurrent = false;\n  };\n}, [userId]); // El efecto se re-ejecuta cada vez que userId cambia\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "advanced",
    "tags": ["useeffect", "race-conditions", "data-fetching", "cleanup"]
  },
  {
    "id": "react-42",
    "question": "¿Por qué los Custom Hooks son la forma preferida de reutilizar lógica, en comparación con HOCs o Render Props?",
    "answer": "Los Custom Hooks son preferidos en React moderno (Hooks-era) porque:\n\n1.  **Evitan el Wrapper Hell:** Los HOCs y Render Props a menudo resultan en un árbol de componentes muy anidado y difícil de leer (ej. `<withRouter><withAuth><MyComponent /></withAuth></withRouter>`). Los Custom Hooks son simplemente llamadas a funciones, lo que resulta en un código de componente más plano y limpio.\n2.  **Mejor Separación de Intereses:** Permiten aislar la lógica con estado y el comportamiento completamente de la capa de renderizado. El componente que usa el hook es responsable de la UI, y el hook es responsable del comportamiento/datos.\n3.  **Facilidad de Combinación:** Puedes componer y combinar fácilmente múltiples Hooks en un solo componente para obtener lógica combinada, algo más complicado con HOCs o Render Props.",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["custom-hooks", "hoc", "render-props", "reusability"]
  },
  {
    "id": "react-43",
    "question": "¿Qué es la 'hidratación' (`Hydration`) en el contexto de React y SSR?",
    "answer": "La **hidratación** es el proceso por el cual React toma un HTML estático que fue pre-renderizado en el **servidor** (SSR) y lo convierte en un HTML dinámico y completamente interactivo en el **navegador** (cliente).\n\n1.  El servidor envía la respuesta HTML y el código JavaScript.\n2.  El usuario ve el HTML renderizado inmediatamente (alto TTI).\n3.  Cuando el JS se carga, React adjunta los manejadores de eventos y la lógica del VDOM al marcado DOM existente, sin tener que volver a renderizar todo el árbol. Si el proceso de hidratación falla (el árbol de React en el cliente no coincide con el HTML pre-renderizado), puede causar errores de desajuste.",
    "context": "React Arquitectura",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "advanced",
    "tags": ["ssr", "hydration", "performance"]
  },
  {
    "id": "react-44",
    "question": "¿Qué hace el Hook `useDebugValue`?",
    "answer": "El Hook **`useDebugValue`** se utiliza para mostrar una etiqueta de soporte para **Custom Hooks** dentro de las **React Developer Tools** (Herramientas de Desarrollador de React).\n\n**Propósito:** Es útil para la depuración de Hooks complejos, permitiendo que los desarrolladores inspeccionen valores de estado interno o lógica en el panel del componente sin tener que inspeccionar el código fuente o usar `console.log`.\n\n**Ejemplo:**\n\n```javascript\nconst useFriendStatus = (friendID) => {\n  const [isOnline, setIsOnline] = useState(null);\n  \n  // Muestra 'Friend Status: Online' o 'Friend Status: Offline' en DevTools\n  useDebugValue(isOnline ? 'Online' : 'Offline');\n\n  return isOnline;\n};\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "advanced",
    "tags": ["usedebugvalue", "hooks", "debugging"]
  },
  {
    "id": "react-45",
    "question": "¿Cuál es la diferencia entre CSS global y CSS Modules?",
    "answer": "| Característica | CSS Global (Archivos .css tradicionales) | CSS Modules (Archivos .module.css) |\n| :--- | :--- | :--- |\n| **Alcance** | Global. Los selectores afectan a toda la aplicación. | **Local y Alcance Fijo**. Los selectores son locales al componente por defecto. |\n| **Colisiones** | Alto riesgo de colisiones de nombres. | Cero riesgo de colisiones de nombres. |\n| **Uso en JS** | Se importa, pero las clases se usan como strings (`className=\"my-class\"`). | Se importa como un objeto. Las clases se acceden como propiedades del objeto. |\n\n**Ejemplo (CSS Modules):**\n\n```css\n/* styles.module.css */\n.heading {\n  color: blue;\n}\n```\n\n```jsx\n// Componente React\nimport styles from './styles.module.css';\n\nconst MyComponent = () => (\n  // El nombre de la clase final será algo único como 'styles_heading__xyz123'\n  <h1 className={styles.heading}>\n    Hello\n  </h1>\n);\n```",
    "context": "React Tooling",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["styling", "css-modules", "css"]
  },
  {
    "id": "react-46",
    "question": "¿Qué sucede en el ciclo de vida del montaje de un componente de clase?",
    "answer": "El ciclo de vida del **Montaje** se refiere al proceso de creación e inserción de la instancia del componente en el DOM. El orden estricto es:\n\n1.  **`constructor(props)`**: Se llama primero. Se utiliza para inicializar el estado local (`this.state = {}`) y enlazar métodos de manejadores de eventos.\n2.  **`static getDerivedStateFromProps(props, state)`**: Se llama justo antes de `render()`. Permite que el componente actualice su estado interno basado en los cambios en las props. Debe devolver un objeto de actualización de estado o `null`.\n3.  **`render()`**: Se llama para examinar `this.props` y `this.state` y devolver el árbol de elementos de React.\n4.  **Actualización del DOM (React 'pinta' el DOM real).**\n5.  **`componentDidMount()`**: Se llama inmediatamente después de que el componente se monta (se inserta en el DOM). Este es el lugar ideal para:\n    -   Peticiones HTTP iniciales (Data fetching).\n    -   Configurar suscripciones o temporizadores.\n    -   Cualquier manipulación del DOM que requiera que el componente esté montado.",
    "context": "React Lifecycle (Class)",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["lifecycle", "class-components", "componentdidmount"]
  },
  {
    "id": "react-47",
    "question": "¿Cómo se realiza la actualización de estado en un componente de clase?",
    "answer": "En un componente de clase, el estado se actualiza mediante el método **`this.setState(updater, callback)`**.\n\n**Puntos clave:**\n1.  **Asíncrono:** `setState` es **asíncrono** y React puede agrupar múltiples llamadas para mejorar el rendimiento. Nunca debes confiar en `this.state` inmediatamente después de llamar a `setState`.\n2.  **Fusión:** `setState` **fusiona** el objeto que le pasas con el estado actual; no lo sobrescribe.\n3.  **Actualización con función:** Si el nuevo estado depende del estado o las props anteriores, debes pasar una **función** en lugar de un objeto. Esto garantiza que estás trabajando con el estado y las props más actualizados.\n\n**Ejemplo (Actualización con Función):**\n\n```javascript\n// Forma recomendada si necesitas el estado anterior\nthis.setState((state, props) => ({\n  // Retorna el nuevo objeto de estado\n  count: state.count + props.step\n}), () => {\n  // Callback opcional que se ejecuta una vez que el estado se ha aplicado y el componente ha re-renderizado\n  console.log('Estado actualizado', this.state.count);\n});\n```",
    "context": "React Lifecycle (Class)",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["state", "setstate", "class-components", "asynchronous"]
  },
  {
    "id": "react-48",
    "question": "¿Cuál es la función del método `return` en el Hook `useEffect`?",
    "answer": "El método `return` dentro del Hook `useEffect` define una **función de limpieza** (`cleanup function`).\n\n**Función:** La función de limpieza se ejecuta:\n1.  Antes de que el efecto se ejecute la próxima vez (si las dependencias han cambiado).\n2.  Cuando el componente se **desmonta** (el equivalente a `componentWillUnmount`).\n\n**Propósito:** Se utiliza para deshacer cualquier efecto secundario, previniendo fugas de memoria y otros problemas. Tareas comunes de limpieza incluyen:\n-   Limpiar temporizadores (`clearTimeout`, `clearInterval`).\n-   Remover *listeners* de eventos (`removeEventListener`).\n-   Cancelar suscripciones.\n\n**Ejemplo (Limpieza de Listener):**\n\n```jsx\nuseEffect(() => {\n  const handleResize = () => { /* ... */ };\n  window.addEventListener('resize', handleResize);\n\n  return () => {\n    // Esto se ejecuta al desmontar o antes del siguiente efecto\n    window.removeEventListener('resize', handleResize);\n  };\n}, []);\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["useeffect", "cleanup", "lifecycle", "side-effects"]
  },
  {
    "id": "react-49",
    "question": "¿Qué es 'Prop Spreading' y cuáles son sus consideraciones de uso?",
    "answer": "**Prop Spreading** (o 'Propagación de Props') es el uso del operador *spread* (`...`) para pasar todas las propiedades de un objeto como props a un componente hijo.\n\n**Ejemplo:**\n\n```jsx\nconst config = { type: 'submit', disabled: true, style: { color: 'red' } };\n\n// Prop Spreading:\n// Pasa { type: 'submit', disabled: true, style: { color: 'red' } } como props\n<Button {...config}>Send</Button>\n```\n\n**Consideraciones:**\n-   **Legibilidad:** Puede reducir la legibilidad, ya que no es inmediatamente obvio qué props se están pasando sin mirar el objeto `config`.\n-   **Seguridad:** Puede pasar props innecesarias o no deseadas a un componente (ej. props de enrutamiento a un componente DOM simple).\n-   **Recomendación:** Úsalo con moderación y preferiblemente para pasar props de DOM estándar (como `id`, `className`, `aria-*`) o para colecciones de props bien conocidas, como en el patrón de HOCs o Render Props.",
    "context": "React Fundamentos",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["props", "spread-operator", "best-practices"]
  },
  {
    "id": "react-50",
    "question": "¿Por qué no se debe llamar a la función `set` de `useState` directamente en el cuerpo del componente?",
    "answer": "Llamar a la función `set` (ej. `setCount(count + 1)`) directamente en el cuerpo de un componente (durante la fase de renderizado) provoca un **bucle infinito de re-renderizado**.\n\n**Flujo del Bucle:**\n1.  React llama al componente para renderizarlo.\n2.  La función `setCount()` se ejecuta.\n3.  `setCount()` actualiza el estado, lo que le dice a React que el componente necesita re-renderizarse.\n4.  Vuelve al paso 1, y el ciclo se repite infinitamente, resultando en un *Stack Overflow* o un congelamiento del navegador.\n\n**Regla:** La actualización del estado solo debe ocurrir dentro de:\n-   Manejadores de eventos (ej. `onClick`, `onSubmit`).\n-   Efectos (ej. `useEffect`, `useLayoutEffect`), donde se ejecutan después del renderizado y el cambio es controlado por dependencias.",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["usestate", "rendering", "infinite-loop", "hooks"]
  }
]