[
  {
    "id": "react-1",
    "question": "What is the main difference between Functional and Class Components in React?",
    "answer": "**Functional Components** are simply JavaScript functions that accept props and return JSX. With the introduction of **Hooks** (React 16.8+), they are the preferred way to write components as they can handle state and side effects, being more concise and easier to test.\n\n**Class Components** are ES6 classes that extend React.Component and require a render() method. They manage state via this.state and the lifecycle via methods like componentDidMount.\n\n**State Example (Functional vs. Class):**\n\n```jsx\n// Functional (with Hooks)\nimport React, { useState } from 'react';\nconst MyFunctionalComp = ({ name }) => {\n  const [count, setCount] = useState(0);\n  return <button onClick={() => setCount(count + 1)}>{name}: {count}</button>;\n};\n\n// Class (Legacy)\nimport React, { Component } from 'react';\nclass MyClassComp extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n  render() {\n    return (\n      <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n        {this.props.name}: {this.state.count}\n      </button>\n    );\n  }\n}\n```",
    "context": "React Components",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["components", "hooks", "class-components", "functional-components"]
  },
  {
    "id": "react-2",
    "question": "What is the Virtual DOM and how does it work in React?",
    "answer": "The **Virtual DOM (VDOM)** is a lightweight abstraction of the real DOM maintained in memory. It is a JavaScript object that maps the DOM.\n\n**Working Flow:**\n1.  When a component's state or props change, React creates a **new VDOM-tree**.\n2.  It uses a **diffing** algorithm to compare the new VDOM with the previous VDOM.\n3.  It identifies the minimal set of changes needed to update the real DOM.\n4.  React efficiently updates **only those parts** of the real DOM, minimizing costly direct browser DOM manipulations.",
    "context": "React Fundamentals",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["virtual-dom", "performance", "rendering"]
  },
  {
    "id": "react-3",
    "question": "What are 'Props' in React and what is their golden rule?",
    "answer": "**Props** (Properties) are a mechanism for passing data from a parent component to a child component, always flowing in one direction, from top to bottom.\n\nThe golden rule is that **Props are immutable ('read-only')**. A component should never modify its own props.\n\n**Example:**\n\n```jsx\n// Parent Component\nconst App = () => {\n  const username = \"Alice\";\n  return <WelcomeMessage user={username} greeting=\"Hello\" />;\n};\n\n// Child Component: Accesses 'user' and 'greeting' via props\nconst WelcomeMessage = (props) => {\n  return <h1>{props.greeting}, {props.user}!</h1>;\n  // Error: props.user = \"Bob\"; // Not allowed, props are read-only\n};\n```",
    "context": "React Components",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["props", "data-flow", "immutability"]
  },
  {
    "id": "react-4",
    "question": "What is 'State' in React and how is it managed in a functional component?",
    "answer": "**State** is a component's private source of truth for data that should change over time. When the state changes, the component **re-renders**.\n\nIn functional components, state is managed with the **useState** Hook, which returns the current state value and a function to update it:\n\n**Example with useState:**\n\n```jsx\nimport React, { useState } from 'react';\n\nconst Counter = () => {\n  // [current state, updater function] = useState(initial value)\n  const [count, setCount] = useState(0);\n\n  const increment = () => {\n    // Best practice: use a function if the new update depends on the previous state\n    setCount(prevCount => prevCount + 1);\n  };\n\n  return <button onClick={increment}>Count: {count}</button>;\n};\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["state", "hooks", "usestate"]
  },
  {
    "id": "react-5",
    "question": "What are Hooks and name some of the most common ones?",
    "answer": "**Hooks** are special functions introduced in React 16.8 that allow developers to \"hook into\" state and React lifecycle features from **functional components**.\n\n**Rules of Hooks:**\n1.  They are only called at the top level of a React functional component.\n2.  They are only called from React functional components or from Custom Hooks.\n\n**Common Hooks:**\n- **useState**: To add local state.\n- **useEffect**: To handle side effects (Data fetching, subscriptions, DOM manipulation).\n- **useContext**: To access React context.\n- **useReducer**: Alternative to useState for more complex state.\n- **useRef**: To reference DOM elements or store mutable values that do not trigger re-rendering.\n- **useCallback, useMemo**: For performance optimization (memoization).",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["hooks", "usestate", "useeffect", "functional-components"]
  },
  {
    "id": "react-6",
    "question": "Explain the purpose of the useEffect Hook?",
    "answer": "The **useEffect** Hook allows you to perform **side effects** in functional components. A 'side effect' is anything that interacts with the outside world or is asynchronous, such as:\n\n- Data fetching.\n- Subscriptions (e.g., browser events).\n- DOM manipulation.\n\n**Signature:** useEffect(setup, dependencies)\n\n**Example (Data Fetching):**\n\n```jsx\nimport React, { useState, useEffect } from 'react';\n\nconst UserProfile = ({ userId }) => {\n  const [user, setUser] = useState(null);\n\n  useEffect(() => {\n    // The effect runs after the component renders\n    fetch(`/api/users/${userId}`)\n      .then(res => res.json())\n      .then(data => setUser(data));\n      \n    // The dependency array [userId] indicates that the effect should re-run\n    // only if the `userId` prop changes between renders.\n  }, [userId]); \n\n  // ...\n};\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["useeffect", "side-effects", "lifecycle", "hooks"]
  },
  {
    "id": "react-7",
    "question": "What is 'prop drilling' and how can it be avoided?",
    "answer": "**Prop Drilling** is the process of passing data down from one component through intermediate components that do not need the data, just so the deepest component in the hierarchy can access it.\n\n**How to avoid it:**\n\n1.  **React Context:** It is the native React way to pass \"global\" or sub-tree specific data, allowing any nested component to consume it directly without manually passing props.\n2.  **State Management Libraries:** Using solutions like Redux, Zustand, or Recoil to store the state in a centralized location, which any component can subscribe to.\n3.  **Composition:** Restructuring components so that the parent component passes the element that needs the data as a prop (e.g., children), delegating the rendering to the direct child, instead of passing the props through several levels.",
    "context": "React Architecture",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["prop-drilling", "context", "architecture", "state-management"]
  },
  {
    "id": "react-8",
    "question": "What is the purpose of the useContext Hook?",
    "answer": "The **useContext** Hook is used to consume the value of the React Context within a functional component. It simplifies access to data shared by a Context.Provider without needing to wrap the component with a Context.Consumer.\n\n**Context Consumption Example:**\n\n```jsx\n// 1. Create Context (in a separate file)\nexport const ThemeContext = createContext('light');\n\n// 2. Consume the Context\nimport { ThemeContext } from './ThemeContext';\nimport React, { useContext } from 'react';\n\nconst ThemedButton = () => {\n  // Gets the 'light' or 'dark' value from the nearest Provider\n  const theme = useContext(ThemeContext);\n  \n  return <button className={theme}>Click Me</button>;\n};\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["usecontext", "context", "state-management", "hooks"]
  },
  {
    "id": "react-9",
    "question": "What is the function of the useMemo Hook and the useCallback Hook?",
    "answer": "Both Hooks are used to **optimize performance** using the technique of **memoization** (caching results):\n\n- **useMemo**: **Memoizes a value**. Used to avoid costly recalculations. The value is only recalculated if one of its dependencies has changed. It returns the memoized **value**.\n- **useCallback**: **Memoizes a callback function**. Used to prevent a function from being redefined on every render. This is crucial when passing functions to child components optimized with React.memo, as an unmemoized function would cause the child to re-render unnecessarily. It returns the memoized **function**.\n\n**useCallback Example:**\n\n```jsx\nconst ParentComponent = ({ itemId }) => {\n  // The handleSave function is only created once, unless itemId changes.\n  const handleSave = useCallback(() => {\n    // Logic to save using itemId\n    console.log(`Saving item ${itemId}`);\n  }, [itemId]);\n\n  // ChildComponent only re-renders if its props change (including handleSave)\n  return <OptimizedChild onSave={handleSave} />;\n};\n\n// OptimizedChild uses React.memo to prevent unnecessary re-renders\nconst OptimizedChild = React.memo(({ onSave }) => { /* ... */ });\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["usememo", "usecallback", "memoization", "performance", "hooks"]
  },
  {
    "id": "react-10",
    "question": "What is the 'key' in React lists and why is it important?",
    "answer": "The **key** is a special attribute that must be included when creating lists of elements in React (typically when mapping an array). The key must be a string or a number that **uniquely and stably identifies** each element among its siblings.\n\n**Importance:** The key helps React's diffing algorithm identify which items have changed, been added, or been removed. Without unique and stable keys, React cannot guarantee that the component's internal state (like form field values or a child component's state) is maintained correctly when the list is reordered or modified. **Using the array index as a key should be avoided if the list can change order.**\n\n**Example:**\n\n```jsx\nconst MyList = ({ items }) => (\n  <ul>\n    {items.map(item => (\n      // Using a unique ID from the data source is the best practice\n      <ListItem key={item.id} data={item} />\n    ))}\n  </ul>\n);\n```",
    "context": "React Fundamentals",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["keys", "lists", "performance", "rendering"]
  },
  {
    "id": "react-11",
    "question": "What is immutability and why is it important in React?",
    "answer": "**Immutability** means that an object or value cannot be modified after its creation. In React, it is essential for **state** and **props**.\n\n**Importance for State:** React relies on immutability to know when a component needs to re-render. When updating state, you must return a **new object or array**, instead of modifying the existing one (mutating it). If you mutate a state object directly, React might think the object reference is the same and not detect the change, resulting in incorrect or null re-rendering.\n\n**Example (Incorrect vs. Correct Way):**\n\n```javascript\n// STATE: { user: { name: 'Alice', age: 30 } }\n\n// ❌ INCORRECT Way (Direct Mutation - React will not detect the change)\nconst updateUserError = (currentUser) => {\n  currentUser.user.age = 31;\n  // setState(currentUser) fails if the object's reference hasn't changed\n  return currentUser;\n};\n\n// ✅ CORRECT Way (Immutability with Spread Operator)\nconst updateUserCorrect = (currentUser) => {\n  return {\n    ...currentUser, // Copy the rest of the state\n    user: {\n      ...currentUser.user, // Copy the sub-object 'user'\n      age: 31 // Overwrite only 'age'\n    }\n  };\n  // setState(newObject) ensures React detects the reference change\n};\n```",
    "context": "React Fundamentals",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["immutability", "state", "props", "performance"]
  },
  {
    "id": "react-12",
    "question": "What is the purpose of the useReducer Hook?",
    "answer": "The **useReducer** Hook is an alternative to useState for state management. It is more suitable when the state is **complex** (it is an object or array with many sub-properties) or when state updates depend on the previous state in an intricate way.\n\nuseReducer accepts a **reducer function** and an initial state, and returns the current state and a dispatch function. This centralizes the state update logic (the *reducer*) outside the component, promoting clarity and testability, following a pattern similar to Redux.\n\n**Signature:** `const [state, dispatch] = useReducer(reducer, initialState);`\n\n**Example (Reducer):**\n\n```javascript\nconst todoReducer = (state, action) => {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return [...state, action.payload];\n    case 'TOGGLE_TODO':\n      return state.map(todo => \n        todo.id === action.id ? { ...todo, completed: !todo.completed } : todo\n      );\n    default:\n      return state;\n  }\n};\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["usereducer", "state-management", "hooks"]
  },
  {
    "id": "react-13",
    "question": "How are HTTP requests (data fetching) handled in a functional component?",
    "answer": "HTTP requests are a **side effect** and are handled within the **useEffect** Hook.\n\n**Data Fetching Pattern with useEffect:**\n\n1.  Define an asynchronous function inside the useEffect callback (or use a self-invoking function, or define the function outside).\n2.  Include a **cleanup function** (useEffect's return) to **cancel the request or ignore the response** if the component unmounts or the effect re-runs before the promise resolves (preventing memory leaks and *race conditions*).\n3.  Use the dependency array ([]) to control when the request re-executes (typically only on initial mount).\n\n**Example (with Cleanup):**\n\n```jsx\nuseEffect(() => {\n  let isSubscribed = true; // Flag for cleanup\n\n  const fetchData = async () => {\n    const response = await fetch('/api/data');\n    const data = await response.json();\n\n    if (isSubscribed) {\n      setState(data);\n    }\n  };\n\n  fetchData();\n\n  return () => { \n    // Cleanup function\n    isSubscribed = false; \n  };\n}, []); // Empty array: runs only on mount\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["data-fetching", "useeffect", "side-effects", "api"]
  },
  {
    "id": "react-14",
    "question": "What is 'component composition' in React?",
    "answer": "**Component Composition** is the fundamental principle of React for building applications from small, independent, and reusable components.\n\nReact favors composition over inheritance. There are two common types:\n\n1.  **Composition by Containment:** When a component is a \"container\" and doesn't know in advance what it will contain. It uses the special **children** prop to render the content passed between its tags.\n\n    ```jsx\n    // Container Component\n    const Card = ({ children }) => (\n      <div className=\"card-box\">\n        {children}\n      </div>\n    );\n    \n    // Usage\n    <Card><p>Flexible content goes here.</p></Card>\n    ``\n\n2.  **Composition by Specialization:** When one component renders another and configures it with props (e.g., a ButtonPrimary that renders a Button with a type='primary'` set).",
    "context": "React Architecture",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["composition", "architecture", "children", "reusability"]
  },
  {
    "id": "react-15",
    "question": "How is the useRef Hook used?",
    "answer": "The **useRef** Hook is used for two main purposes, as it returns a mutable object whose .current property is initialized with the passed argument:\n\n1.  **Accessing the DOM:** Obtaining a direct reference to a DOM element (i.e., the underlying HTML element).\n2.  **Storing a mutable value:** Holding any value that needs to persist across re-renders without causing the component to re-render when it changes (unlike useState).\n\n**DOM Access Example:**\n\n```jsx\nimport React, { useRef } from 'react';\n\nconst TextInput = () => {\n  const inputRef = useRef(null);\n\n  const focusInput = () => {\n    // Accesses the underlying DOM element (the <input>)\n    inputRef.current.focus();\n  };\n\n  return (\n    <>\n      <input ref={inputRef} type=\"text\" />\n      <button onClick={focusInput}>Focus Input</button>\n    </>\n  );\n};\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["useref", "dom", "refs", "hooks"]
  },
  {
    "id": "react-16",
    "question": "What is React.memo and when should it be used?",
    "answer": "**React.memo** is a Higher-Order Component (HOC) used to **optimize the performance** of **functional components**.\n\nIt acts as a rendering \"gate\": if the props received by a component are the same as in the previous render, React skips the re-render of that component and reuses the memoized (cached) result.\n\n**When to use it:** When a component:\n1.  Re-renders frequently.\n2.  Receives the same props most of the time.\n3.  Re-rendering is costly (slow).\n\n**Note:** For memoized child components, it is crucial to use useCallback or useMemo for their function/object props; otherwise, React will see them as 'changed' on every parent render.",
    "context": "React Performance",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["react.memo", "performance", "memoization", "hoc"]
  },
  {
    "id": "react-17",
    "question": "What is a 'Higher-Order Component' (HOC)?",
    "answer": "A **Higher-Order Component (HOC)** is an advanced technique for logic reuse in React. An HOC is a **function** that takes a component as an argument and returns a **new enhanced component** (wrapped) with additional logic, data, or functionality.\n\n**Signature:** const NewComponent = higherOrderComponent(OriginalComponent);\n\n**Use Case:** Sharing non-visual logic (e.g., subscription management, data loading logic, authentication handling).\n\n**Example (Conceptual):**\n\n```javascript\n// HOC that injects an 'isLoading' prop\nconst withLoading = (WrappedComponent) => {\n  return class WithLoading extends React.Component {\n    state = { isLoading: true };\n    componentDidMount() { \n      // Simulates data fetching\n      setTimeout(() => this.setState({ isLoading: false }), 1000);\n    }\n    render() {\n      if (this.state.isLoading) return <div>Loading...</div>;\n      // Passes all original props plus the extra logic\n      return <WrappedComponent {...this.props} isLoading={this.state.isLoading} />;\n    }\n  };\n};\n\n// Usage of the HOC\nconst EnhancedList = withLoading(UserList);\n```",
    "context": "React Architecture",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "advanced",
    "tags": ["hoc", "patterns", "reusability", "architecture"]
  },
  {
    "id": "react-18",
    "question": "How is routing handled in a React application?",
    "answer": "Client-side routing is typically handled using the **React Router (v6+)** library. This library uses the browser's History API to keep the User Interface (UI) in sync with the URL.\n\n**Key Concepts (React Router v6):**\n- **BrowserRouter**: The component that wraps the entire application and provides the routing context.\n- **Routes**: A container where all possible routes are defined.\n- **Route**: Used to map a URL path to the component that should be rendered (element).\n- **Link**: A component for declarative navigation that prevents a full page reload.\n- **useNavigate, useParams**: Hooks for programmatic navigation and reading URL parameters, respectively.\n\n**Example (React Router v6):**\n\n```jsx\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\n\nconst App = () => (\n  <BrowserRouter>\n    <Routes>\n      <Route path=\"/\" element={<HomePage />} />\n      <Route path=\"/users/:userId\" element={<UserProfile />} />\n      <Route path=\"*\" element={<NotFoundPage />} />\n    </Routes>\n  </BrowserRouter>\n);\n```",
    "context": "React Tooling",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["react-router", "routing", "hooks"]
  },
  {
    "id": "react-19",
    "question": "What are 'Synthetic Events' in React?",
    "answer": "**Synthetic Events** are a React wrapper around the browser's native event system.\n\n**Purpose and Features:**\n1.  **Normalization:** They provide a consistent and normalized event API across all browsers, eliminating compatibility concerns (e.g., event.target works the same everywhere).\n2.  **Event Pool (Deprecated):** In older React versions, event objects were reused for performance reasons. Although this no longer happens in React 17+, the recommendation not to access the event object asynchronously (unless you extract it first) remains relevant in most use cases to avoid surprises.",
    "context": "React Fundamentals",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["events", "synthetic-events", "dom", "performance"]
  },
  {
    "id": "react-20",
    "question": "Explain what 'Fragments' (<> or <React.Fragment>) are and how they are used?",
    "answer": "**Fragments** are a special component that allows you to group a list of child elements **without adding an extra node to the DOM** (i.e., without an unnecessary wrapping div).\n\n**Purpose:** They are crucial for maintaining valid HTML semantics (e.g., when rendering table cells where the parent *must* be a <tr>) or when working with CSS structures like Flexbox or Grid, where a wrapping div could break the layout.\n\n**Syntax:**\n\n```jsx\n// Long Syntax\nimport React, { Fragment } from 'react';\n<Fragment>\n  <td>Column 1</td>\n  <td>Column 2</td>\n</Fragment>\n\n// Short Syntax (more common)\n<>\n  <Header />\n  <Content />\n</>\n// NOTE: The short syntax does not support the 'key' attribute.\n```",
    "context": "React Fundamentals",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["fragments", "jsx", "dom"]
  },
  {
    "id": "react-21",
    "question": "What is the 'render props' pattern?",
    "answer": "The **Render Props** pattern is a technique for sharing code and logic between React components. A component with a 'render prop' takes a **function** as a prop (often called render or children) and calls that function to determine what to render, passing data or logic as an argument.\n\n**Advantage:** It allows the parent component (the one implementing the logic) to inject data or behavior into the child component, delegating the UI rendering entirely to the consumer.\n\n**Example (Component implementing the pattern):**\n\n```jsx\nconst MouseTracker = ({ render }) => {\n  const [coords, setCoords] = useState({ x: 0, y: 0 });\n  // ... (Logic to handle onMouseMove event)\n\n  // Calls the 'render' prop and passes the state\n  return <div>{render(coords)}</div>;\n};\n\n// Usage by the Consumer:\n<MouseTracker render={mouse => (\n  <h1>Mouse Position: ({mouse.x}, {mouse.y})</h1>\n)} />\n```",
    "context": "React Architecture",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "advanced",
    "tags": ["patterns", "render-props", "reusability"]
  },
  {
    "id": "react-22",
    "question": "When should you choose between useMemo and useCallback?",
    "answer": "The choice depends on whether you are memoizing a **value** or a **function**:\n\n| Hook | Main Purpose | Return Value | Common Dependencies | Typical Use Case |\n| :--- | :--- | :--- | :--- | :--- |\n| **useMemo** | Avoid costly recalculations of a value. | The memoized **value**. | State variables, props, function results. | Filtering large arrays, complex mathematical calculations. |\n| **useCallback** | Prevent the re-creation of functions. | The memoized **function**. | State variables, props used in the function. | Passing functions to memoized child components (React.memo) to prevent unnecessary re-renders. |\n\n**General Rule:** If the result is a primitive value, object, or array, use **useMemo**. If the result is a function, use **useCallback** (especially if passed as a prop).",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["usememo", "usecallback", "performance", "hooks"]
  },
  {
    "id": "react-23",
    "question": "What is 'lifting state up' and why is it done?",
    "answer": "**Lifting State Up** is a technique for sharing state or synchronizing it between two or more sibling components or components that do not have a direct parent-child relationship. It involves moving the state to their **closest common ancestor**.\n\n**Process:**\n1.  The state is declared and maintained in the ancestor component (e.g., ParentComponent).\n2.  The ancestor component passes the data (state) to the child components as **props**.\n3.  The ancestor component passes a **callback function** to the children via props. The children call this function to request a state update from the ancestor.\n\nThis ensures there is a **single source of truth** for that piece of data, facilitating synchronization and React's unidirectional data flow.",
    "context": "React Components",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["state", "data-flow", "architecture"]
  },
  {
    "id": "react-24",
    "question": "How do you test a React component? (Mention tools and types of testing)",
    "answer": "Testing of React components is divided into different levels:\n\n1.  **Unit/Component Tests (Testing Library/Jest):** Focus on the isolated unit. **React Testing Library** (preferred) is used along with **Jest** to render components in a simulated DOM environment and test how the component behaves through simulated user interaction. Testing Library's philosophy is: \"Test the component the way the user would\".\n\n    ```javascript\n    // Testing Library Example\n    import { render, screen } from '@testing-library/react';\n    import userEvent from '@testing-library/user-event';\n    \n    test('Button increments counter on click', async () => {\n      render(<Counter />);\n      const button = screen.getByText(/Count: 0/i);\n      await userEvent.click(button);\n      expect(screen.getByText(/Count: 1/i)).toBeInTheDocument();\n    });\n    ```\n\n2.  **End-to-End (E2E) Tests (Cypress/Playwright):** Test the user flow through the application in a real browser, covering backend and frontend integration.",
    "context": "React Tooling",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["testing", "jest", "testing-library"]
  },
  {
    "id": "react-25",
    "question": "What is 'Strict Mode' (<React.StrictMode>) and its purpose?",
    "answer": "**React.StrictMode** is a development tool used to highlight potential problems in an application. It does not render any visible UI and only works in development mode.\n\n**Purpose:** It activates additional checks and warnings, including:\n-   Identifying components with unsafe side effects (e.g., calling useEffect twice to expose cleanup issues).\n-   Warning about the use of deprecated class component lifecycle APIs.\n-   Detecting the use of the legacy string ref API.\n-   Warning about unexpected side effects in the rendering process (double invocation of render functions and class methods).",
    "context": "React Fundamentals",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["strictmode", "debugging", "development"]
  },
  {
    "id": "react-26",
    "question": "How is performance optimization handled when rendering very long lists?",
    "answer": "To optimize very long lists (hundreds or thousands of elements), the concept of **Virtualization** or **Windowing** is used.\n\n**Virtualization/Windowing:** This is a technique that only renders the list items that are **visible** to the user in the current viewport, plus a small number of adjacent items. As the user scrolls, the necessary DOM elements are dynamically created and destroyed.\n\n-   **Advantage:** Drastically reduces the number of DOM nodes the browser needs to handle, significantly improving scrolling performance and load time.\n-   **Common Libraries:** **react-window** (smaller and focused) or **react-virtualized** (more complete) implement this logic.",
    "context": "React Performance",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["performance", "lists", "virtualization"]
  },
  {
    "id": "react-27",
    "question": "What is the main difference between Server-Side Rendering (SSR) and Client-Side Rendering (CSR)?",
    "answer": "| Feature | CSR (Client-Side Rendering - Traditional React) | SSR (Server-Side Rendering - Next.js, etc.) |\n| :--- | :--- | :--- |\n| **Initial HTML** | An almost empty HTML is sent (`<div id=\"root\"></div>`). | The complete HTML of the page is sent. |\n| **Initial Rendering** | Happens in the **browser** (client) after the JS is downloaded. | Happens on the **server**. |\n| **Content Time** | The user sees a blank page or a spinner until the JS loads and executes. | The user sees the content immediately (good TTI). |\n| **SEO** | Can be a challenge for search engine crawlers that don't execute JS. | Excellent, the crawler receives rendered content. |\n\nWith **SSR**, the initial HTML is rendered on the server and then React \"hydrates\" that HTML in the browser to make it interactive.",
    "context": "React Architecture",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["ssr", "csr", "nextjs", "performance"]
  },
  {
    "id": "react-28",
    "question": "What is JSX and how is it converted into code the browser understands?",
    "answer": "**JSX** (JavaScript XML) is a syntax extension to JavaScript that allows you to write HTML-like code structures within JavaScript files. It is neither HTML nor a string, but syntactic sugar.\n\n**Conversion (Transpilation):** JSX code is converted into standard React JavaScript function calls using a **transpiler** like **Babel**. Specifically, it transforms JSX tags into calls to React.createElement() (or _jsx in React 17+).\n\n**Transpilation Example:**\n\n```jsx\n// JSX Code\nconst element = <h1 className=\"greeting\">Hello, world!</h1>;\n\n// JavaScript Code (Transpiled by Babel)\nconst element = React.createElement(\n  'h1',\n  { className: 'greeting' },\n  'Hello, world!'\n);\n```",
    "context": "React Fundamentals",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["jsx", "babel", "virtual-dom"]
  },
  {
    "id": "react-29",
    "question": "How is a Custom Hook defined and what is its purpose?",
    "answer": "A **Custom Hook** is a regular JavaScript function whose name **must start with the prefix use** (e.g., useFetch, useLocalStorage).\n\n**Purpose:** It serves to **reuse stateful logic** between different functional components without sharing the user interface. It allows isolating complex logic (form management, timer handling, API subscription logic) into a reusable function.\n\n**Example (useToggle):**\n\n```javascript\n// custom hook\nconst useToggle = (initialValue = false) => {\n  const [value, setValue] = useState(initialValue);\n\n  const toggle = useCallback(() => {\n    setValue(currentValue => !currentValue);\n  }, []);\n\n  return [value, toggle];\n};\n\n// Usage in a component\nconst MyComponent = () => {\n  const [isDarkMode, toggleDarkMode] = useToggle(false);\n  return <button onClick={toggleDarkMode}>Toggle Dark Mode</button>;\n};\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["custom-hooks", "hooks", "reusability", "architecture"]
  },
  {
    "id": "react-30",
    "question": "What are 'Portals' in React?",
    "answer": "A **Portal** is a way to render a child component into a DOM node that **exists outside the DOM hierarchy of the calling parent component**.\n\nThe function **ReactDOM.createPortal(child, container)** is used.\n\n**Common Use Case:** They are ideal for modals, tooltips, notifications, or floating menus, as they allow the component to render directly in a place like document.body. This solves styling issues (such as z-index, overflow: hidden, or position: relative) that the parent component might impose, allowing the child element to display correctly on top of everything.",
    "context": "React Advanced",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "advanced",
    "tags": ["portals", "dom", "rendering"]
  },
  {
    "id": "react-31",
    "question": "How is the useLayoutEffect Hook used and how does it differ from useEffect?",
    "answer": "- **useEffect**: Runs **asynchronously** after the browser has painted (repainted) the DOM (after rendering).\n- **useLayoutEffect**: Is identical to useEffect in its signature, but fires **synchronously** immediately after React has performed DOM mutations, but **before** the browser paints the result to the screen.\n\n**When to use useLayoutEffect:** When you need to measure the DOM, or perform DOM modifications that might change the layout or position, and you want those changes to be visible **before** the user sees the first paint. If you use useEffect in these cases, the user might see a visual \"flicker\" before the correction is applied. Use it sparingly as it blocks the browser's paint.\n\n**Example (Measurement and Adjustment):**\n\n```jsx\nconst Tooltip = () => {\n  const ref = useRef();\n  \n  useLayoutEffect(() => {\n    // Measures the element's position after rendering\n    const { width } = ref.current.getBoundingClientRect();\n    // Adjusts the position (changes the style) immediately, before the browser paints\n    // ...\n  }, []);\n  return <div ref={ref}>...</div>;\n};\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "advanced",
    "tags": ["useeffect", "uselayouteffect", "dom", "hooks"]
  },
  {
    "id": "react-32",
    "question": "How do you make an API call that re-runs only when a userId changes?",
    "answer": "The **useEffect** Hook is used, and the userId variable is included in its **dependency array**.\n\nBy including [userId], React ensures that:\n1.  The effect runs after the initial mount.\n2.  The effect runs **only** if the userId value has changed since the last render.\n\n**Detailed Example (with Cleanup and Dependencies):**\n\n```jsx\nimport React, { useState, useEffect } from 'react';\n\nfunction UserProfile({ userId }) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n\n  useEffect(() => {\n    let isSubscribed = true; // Cleanup flag\n    setLoading(true);\n    setData(null);\n\n    fetch(`/api/users/${userId}`)\n      .then(res => res.json())\n      .then(newData => {\n        if (isSubscribed) {\n          setData(newData);\n          setLoading(false);\n        }\n      })\n      .catch(error => {\n        if (isSubscribed) console.error(error);\n      });\n\n    return () => {\n      // Cleanup: prevents the asynchronous response from updating stale/unmounted state\n      isSubscribed = false;\n    };\n  }, [userId]); // <--- Key Dependency\n\n  if (loading) return <div>Loading user {userId}...</div>;\n  return <div>{/* ... Render data ... */}</div>;\n}\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["useeffect", "data-fetching", "hooks", "dependencies"]
  },
  {
    "id": "react-33",
    "question": "What is 'Redux' and why is it used in a React application?",
    "answer": "**Redux** is a JavaScript library for **predictable state management**. It is used to centralize the global state of a React application. It provides a single state container (store) that is the \"single source of truth\".\n\n**Used for:**\n-   Managing state that needs to be shared by many components.\n-   Facilitating debugging and tracking state changes over time (thanks to immutability and Redux DevTools).\n\n**Redux Cycle (The \"Unidirectional Flow\"):**\n1.  **View (React Component)**: Dispatches an **Action** (a simple JS object describing what happened).\n2.  **Dispatch**: Sends the Action to the **Reducer** function.\n3.  **Reducer**: Is a **pure** function that takes the previous state and the Action, and returns a **new state object** (always immutably).\n4.  **Store**: Stores the new state, notifies the View, and the React component re-renders with the new state.",
    "context": "State Management",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["redux", "state-management", "store", "architecture"]
  },
  {
    "id": "react-34",
    "question": "What are React 'Contexts' and when should they be used instead of Redux?",
    "answer": "The React **Context API** is designed to share data considered **\"global\"** (such as theme, language, or authenticated user information) through a component sub-tree without having to manually pass props.\n\n**Context vs. Redux (or similar):**\n\n-   **Use Context when:** The state is simple, does not change very often, and is local to a part of the component tree. It is ideal for avoiding *prop drilling* in configuration and theming scenarios.\n-   **Use Redux/Zustand when:** The state is highly complex, changes frequently, and the application requires a system for managing side effects (middleware), advanced debugging tools, and a history of state actions. Redux is more suitable for complex, high-traffic application state.",
    "context": "React Context",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["context", "redux", "state-management", "usecontext"]
  },
  {
    "id": "react-35",
    "question": "What is the syntax for passing a component as a children prop?",
    "answer": "The special **children** prop refers to the content passed between the opening and closing JSX tags of a component. It is not passed as an explicit prop `children={...}` but as nested content.\n\n**Example:**\n\n```jsx\n// Container Component (Parent)\nconst Layout = ({ header, children }) => {\n  return (\n    <div className=\"layout\">\n      <header>{header}</header> {/* Renders the explicit 'header' prop */}\n      <main>{children}</main>   {/* Renders the nested content */}\n    </div>\n  );\n};\n\n// Usage by the Consumer\nconst Page = () => (\n  <Layout \n    header={<h2>My Header</h2>} // Explicit prop\n  >\n    {/* This is the value of the 'children' prop */}\n    <p>The main body of the page.</p>\n    <Button text=\"Home\" />\n  </Layout>\n);\n```",
    "context": "React Components",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["composition", "children", "props"]
  },
  {
    "id": "react-36",
    "question": "How are forms and 'controlled components' handled in React?",
    "answer": "A **Controlled Component** is a form input element (input, textarea, select) whose value is completely controlled by the **React state**.\n\n**Handling:**\n1.  The field's value is set to a state variable (`value={stateValue}`).\n2.  An event handler (onChange) is attached that listens for user changes and **updates the state**.\n3.  The state update triggers a re-render, and the field's value is updated with the new stateValue.\n\n**Example (Controlled Input):**\n\n```jsx\nconst MyForm = () => {\n  const [name, setName] = useState('');\n\n  const handleChange = (event) => {\n    // The input value is now the state, and is only updated via React\n    setName(event.target.value);\n  };\n\n  return (\n    <input \n      type=\"text\"\n      value={name} // 1. The value is tied to the state\n      onChange={handleChange} // 2. The change updates the state\n    />\n  );\n};\n```",
    "context": "React Fundamentals",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["forms", "controlled-components", "state"]
  },
  {
    "id": "react-37",
    "question": "What are 'uncontrolled components' and when are they used?",
    "answer": "An **Uncontrolled Component** is a form element where the data is managed by the **DOM itself**, in the traditional HTML way. React only intervenes when you need the value (for example, upon form submission).\n\n**Usage:** Instead of an onChange handler, a **ref** is used to access the DOM element and get its current value (typically via ref.current.value).\n\n**When to use them:**\n-   For simple forms or inputs where instant validation or feedback is not needed, simplifying the code.\n-   Often used with external UI libraries that manage their own DOM state.\n\n**Example (Uncontrolled Input):**\n\n```jsx\nconst MyForm = () => {\n  const inputRef = useRef();\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    // The value is read directly from the DOM using the ref\n    alert(`Submitted: ${inputRef.current.value}`);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input type=\"text\" ref={inputRef} defaultValue=\"Initial Value\" />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n};\n```",
    "context": "React Fundamentals",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["forms", "uncontrolled-components", "refs"]
  },
  {
    "id": "react-38",
    "question": "What is the function of the useImperativeHandle Hook?",
    "answer": "The **useImperativeHandle** Hook is used to customize the **instance value** that is exposed to parent components when they use a ref to access the child component.\n\n**Usage:** It is always used in conjunction with **forwardRef** and serves to expose **only the specific functions or properties** that you want the parent to access, rather than the entire child component instance (which is a good encapsulation practice).\n\n**Example:** Only allows the parent to call the child's focus function.\n\n```jsx\nconst FancyInput = forwardRef((props, ref) => {\n  const inputRef = useRef();\n\n  useImperativeHandle(ref, () => ({\n    // The returned object is what the parent will see as 'ref.current'\n    focus: () => {\n      inputRef.current.focus();\n    },\n    // You could add more methods: clearValue: () => {...}\n  }));\n\n  return <input ref={inputRef} {...props} />;\n});\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "advanced",
    "tags": ["useimperativehandle", "forwardref", "refs", "hooks"]
  },
  {
    "id": "react-39",
    "question": "How is accessibility (a11y) handled in React?",
    "answer": "React facilitates building accessible components by adhering to web standards (WAI-ARIA). Key guidelines include:\n\n1.  **Semantic HTML:** Prioritize the use of semantic HTML tags (<button>, <nav>, <h1>) instead of generic divs, as they have inherent meaning for screen readers.\n2.  **aria- Attributes:** Use ARIA attributes (e.g., aria-label, aria-hidden, role) when HTML elements do not convey the necessary information about the UI state or function (e.g., a custom div acting as a button).\n3.  **Focus Management:** Ensure all interactive elements are focusable and operable with the keyboard (using tabIndex if necessary, but avoiding it if possible).\n4.  **Fragments:** To avoid adding unnecessary DOM elements that could interfere with semantic or accessibility structure.\n\n**ARIA Example:**\n\n```jsx\n// A progress component that uses ARIA to communicate its value\nconst ProgressBar = ({ value }) => (\n  <div \n    role=\"progressbar\" // Indicates this element is a progress bar\n    aria-valuenow={value} // Indicates the current value\n    aria-valuemin=\"0\"\n    aria-valuemax=\"100\"\n  >\n    {value}%\n  </div>\n);\n```",
    "context": "React Best Practices",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["a11y", "accessibility", "best-practices", "html"]
  },
  {
    "id": "react-40",
    "question": "What are 'Error Boundaries' and how are they implemented?",
    "answer": "**Error Boundaries** are React components (only **class** components) that have the ability to:\n\n1.  **Catch JavaScript errors** anywhere in their descendant component tree (in lifecycle methods, rendering, and constructors).\n2.  **Log** those errors.\n3.  **Display a fallback UI** instead of the component tree that crashed.\n\n**Key Implementation Methods:**\n\n```jsx\nclass ErrorBoundary extends React.Component {\n  state = { hasError: false };\n\n  // 1. Called after a descendant throws an error. Updates the state.\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n\n  // 2. Used to log error information (e.g., to a logging service).\n  componentDidCatch(error, errorInfo) {\n    console.error(\"Uncaught error:\", error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <h1>Something went wrong.</h1>; // Fallback UI\n    }\n    return this.props.children;\n  }\n}\n```\n\n**Note:** They do not catch errors within event handlers or asynchronous calls (setTimeout, fetch`).",
    "context": "React Advanced",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["error-boundaries", "error-handling", "lifecycle"]
  },
  {
    "id": "react-41",
    "question": "How do you solve a *race condition* in an API call inside useEffect?",
    "answer": "A *race condition* in useEffect occurs when multiple asynchronous calls are started and complete in a different order than they were initiated (e.g., the user quickly changes tabs, the slow previous call resolves after the fast subsequent one, updating the state incorrectly).\n\nThis is solved by using the **cleanup function** of useEffect along with a **flag** to indicate whether the current response should be ignored, as a new request has already been started (or the component unmounted).\n\n**Example (Flag Technique):**\n\n```jsx\nuseEffect(() => {\n  let isCurrent = true; // Flag is initialized to true\n\n  fetchData(userId).then(data => {\n    // Only update state if this request is still the \"most recent\" and the component is still mounted\n    if (isCurrent) {\n      setData(data);\n    }\n  });\n\n  return () => {\n    // Cleanup runs before the next effect, marking the previous one as stale\n    isCurrent = false;\n  };\n}, [userId]); // The effect re-runs every time userId changes\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "advanced",
    "tags": ["useeffect", "race-conditions", "data-fetching", "cleanup"]
  },
  {
    "id": "react-42",
    "question": "Why are Custom Hooks the preferred way to reuse logic, compared to HOCs or Render Props?",
    "answer": "Custom Hooks are preferred in modern React (Hooks-era) because:\n\n1.  **Avoid Wrapper Hell:** HOCs and Render Props often result in a deeply nested and hard-to-read component tree (e.g., <withRouter><withAuth><MyComponent /></withAuth></withRouter>). Custom Hooks are simply function calls, resulting in flatter, cleaner component code.\n2.  **Better Separation of Concerns:** They allow completely isolating stateful logic and behavior from the rendering layer. The component using the hook is responsible for the UI, and the hook is responsible for behavior/data.\n3.  **Ease of Combination:** You can easily compose and combine multiple Hooks within a single component for combined logic, which is more complicated with HOCs or Render Props.",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["custom-hooks", "hoc", "render-props", "reusability"]
  },
  {
    "id": "react-43",
    "question": "What is 'Hydration' in the context of React and SSR?",
    "answer": "**Hydration** is the process by which React takes static HTML that was pre-rendered on the **server** (SSR) and converts it into dynamic, fully interactive HTML on the **browser** (client).\n\n1.  The server sends the HTML response and the JavaScript code.\n2.  The user sees the rendered HTML immediately (high TTI).\n3.  When the JS loads, React attaches event handlers and VDOM logic to the existing DOM markup, without having to re-render the entire tree. If the hydration process fails (the React tree on the client does not match the pre-rendered HTML), it can cause mismatch errors.",
    "context": "React Architecture",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "advanced",
    "tags": ["ssr", "hydration", "performance"]
  },
  {
    "id": "react-44",
    "question": "What does the useDebugValue Hook do?",
    "answer": "The **useDebugValue** Hook is used to display a support label for **Custom Hooks** inside the **React Developer Tools**.\n\n**Purpose:** It is useful for debugging complex Hooks, allowing developers to inspect internal state values or logic in the component panel without having to inspect the source code or use console.log.\n\n**Example:**\n\n```javascript\nconst useFriendStatus = (friendID) => {\n  const [isOnline, setIsOnline] = useState(null);\n  \n  // Displays 'Friend Status: Online' or 'Friend Status: Offline' in DevTools\n  useDebugValue(isOnline ? 'Online' : 'Offline');\n\n  return isOnline;\n};\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "advanced",
    "tags": ["usedebugvalue", "hooks", "debugging"]
  },
  {
    "id": "react-45",
    "question": "What is the difference between global CSS and CSS Modules?",
    "answer": "| Feature | Global CSS (Traditional .css files) | CSS Modules (.module.css files) |\n| :--- | :--- | :--- |\n| **Scope** | Global. Selectors affect the entire application. | **Local and Fixed Scope**. Selectors are local to the component by default. |\n| **Collisions** | High risk of name collisions. | Zero risk of name collisions. |\n| **Usage in JS** | Imported, but classes are used as strings (className=\"my-class\"). | Imported as an object. Classes are accessed as object properties. |\n\n**Example (CSS Modules):**\n\n```css\n/* styles.module.css */\n.heading {\n  color: blue;\n}\n``\n\n``jsx\n// React Component\nimport styles from './styles.module.css';\n\nconst MyComponent = () => (\n  // The final class name will be something unique like 'styles_heading__xyz123'\n  <h1 className={styles.heading}>\n    Hello\n  </h1>\n);\n```",
    "context": "React Tooling",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["styling", "css-modules", "css"]
  },
  {
    "id": "react-46",
    "question": "What happens in the mounting lifecycle of a class component?",
    "answer": "The **Mounting** lifecycle refers to the process of creating and inserting the component instance into the DOM. The strict order is:\n\n1.  **constructor(props)**: Called first. Used to initialize local state (`this.state = {}`) and bind event handler methods.\n2.  **static getDerivedStateFromProps(props, state)**: Called right before render(). Allows the component to update its internal state based on changes in props. It must return a state update object or null.\n3.  **render()**: Called to examine this.props and this.state and return the React element tree.\n4.  **DOM Update (React 'paints' the actual DOM).**\n5.  **componentDidMount()**: Called immediately after the component is mounted (inserted into the DOM). This is the ideal place for:\n    -   Initial HTTP requests (Data fetching).\n    -   Setting up subscriptions or timers.\n    -   Any DOM manipulation that requires the component to be mounted.",
    "context": "React Lifecycle (Class)",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["lifecycle", "class-components", "componentdidmount"]
  },
  {
    "id": "react-47",
    "question": "How is state updated in a class component?",
    "answer": "In a class component, state is updated using the method **this.setState(updater, callback)**.\n\n**Key Points:**\n1.  **Asynchronous:** setState is **asynchronous**, and React may batch multiple calls to improve performance. You should never rely on this.state immediately after calling setState.\n2.  **Merging:** setState **merges** the object you pass to it with the current state; it does not overwrite it.\n3.  **Function Update:** If the new state depends on the previous state or props, you should pass a **function** instead of an object. This ensures you are working with the most up-to-date state and props.\n\n**Example (Function Update):**\n\n```javascript\n// Recommended way if you need the previous state\nthis.setState((state, props) => ({\n  // Returns the new state object\n  count: state.count + props.step\n}), () => {\n  // Optional callback that runs once the state has been applied and the component has re-rendered\n  console.log('State updated', this.state.count);\n});\n```",
    "context": "React Lifecycle (Class)",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "beginner",
    "tags": ["state", "setstate", "class-components", "asynchronous"]
  },
  {
    "id": "react-48",
    "question": "What is the function of the return method in the useEffect Hook?",
    "answer": "The return method inside the useEffect Hook defines a **cleanup function**.\n\n**Function:** The cleanup function runs:\n1.  Before the effect runs the next time (if dependencies have changed).\n2.  When the component **unmounts** (the equivalent of componentWillUnmount).\n\n**Purpose:** It is used to undo any side effects, preventing memory leaks and other issues. Common cleanup tasks include:\n-   Clearing timers (clearTimeout, clearInterval).\n-   Removing event *listeners* (removeEventListener).\n-   Canceling subscriptions.\n\n**Example (Listener Cleanup):**\n\n```jsx\nuseEffect(() => {\n  const handleResize = () => { /* ... */ };\n  window.addEventListener('resize', handleResize);\n\n  return () => {\n    // This runs on unmount or before the next effect\n    window.removeEventListener('resize', handleResize);\n  };\n}, []);\n```",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["useeffect", "cleanup", "lifecycle", "side-effects"]
  },
  {
    "id": "react-49",
    "question": "What is 'Prop Spreading' and what are its usage considerations?",
    "answer": "**Prop Spreading** is the use of the spread operator (...) to pass all properties of an object as props to a child component.\n\n**Example:**\n\n```jsx\nconst config = { type: 'submit', disabled: true, style: { color: 'red' } };\n\n// Prop Spreading:\n// Passes { type: 'submit', disabled: true, style: { color: 'red' } } as props\n<Button {...config}>Send</Button>\n```\n\n**Considerations:**\n-   **Readability:** It can reduce readability, as it's not immediately obvious which props are being passed without looking at the config object.\n-   **Safety:** It can pass unnecessary or unwanted props to a component (e.g., routing props to a simple DOM component).\n-   **Recommendation:** Use it sparingly and preferably to pass standard DOM props (like id, className, aria-*`) or for collections of well-known props, such as in the HOC or Render Props pattern.",
    "context": "React Fundamentals",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["props", "spread-operator", "best-practices"]
  },
  {
    "id": "react-50",
    "question": "Why should you not call the useState setter function directly in the component body?",
    "answer": "Calling the setter function (e.g., setCount(count + 1)) directly in the body of a component ( during the rendering phase) causes an **infinite re-render loop**.\n\n**Loop Flow:**\n1.  React calls the component to render it.\n2.  The setCount() function executes.\n3.  setCount() updates the state, which tells React that the component needs to re-render.\n4.  The cycle goes back to step 1, and repeats infinitely, resulting in a *Stack Overflow* or browser freeze.\n\n**Rule:** State updates should only occur within:\n-   Event handlers (e.g., onClick, onSubmit).\n-   Effects (e.g., useEffect, useLayoutEffect), where they run after rendering and the change is controlled by dependencies.",
    "context": "React Hooks",
    "type": "TECHNICAL",
    "programming_language": "react",
    "difficulty": "intermediate",
    "tags": ["usestate", "rendering", "infinite-loop", "hooks"]
  }
]